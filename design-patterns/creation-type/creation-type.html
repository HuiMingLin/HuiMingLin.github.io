<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>创建型模式 | Ryan Lin 的小书房</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/0.styles.17f32d1e.css" as="style"><link rel="preload" href="/assets/js/app.7b557cf4.js" as="script"><link rel="preload" href="/assets/js/2.9d2502b9.js" as="script"><link rel="preload" href="/assets/js/15.581d44ad.js" as="script"><link rel="prefetch" href="/assets/js/10.abca38ac.js"><link rel="prefetch" href="/assets/js/11.533a137f.js"><link rel="prefetch" href="/assets/js/12.09bfe638.js"><link rel="prefetch" href="/assets/js/13.6809eae0.js"><link rel="prefetch" href="/assets/js/14.5b42a10c.js"><link rel="prefetch" href="/assets/js/16.015d76f3.js"><link rel="prefetch" href="/assets/js/17.05f4e776.js"><link rel="prefetch" href="/assets/js/18.be846678.js"><link rel="prefetch" href="/assets/js/19.96606190.js"><link rel="prefetch" href="/assets/js/20.bb2d1d13.js"><link rel="prefetch" href="/assets/js/21.25bb610e.js"><link rel="prefetch" href="/assets/js/22.470a03d7.js"><link rel="prefetch" href="/assets/js/23.ac5167e8.js"><link rel="prefetch" href="/assets/js/24.0ee61759.js"><link rel="prefetch" href="/assets/js/25.b5c31bf2.js"><link rel="prefetch" href="/assets/js/26.54c07ad2.js"><link rel="prefetch" href="/assets/js/27.0c2ac7b0.js"><link rel="prefetch" href="/assets/js/3.4de31ec5.js"><link rel="prefetch" href="/assets/js/4.3ff2fe10.js"><link rel="prefetch" href="/assets/js/5.c1f49f56.js"><link rel="prefetch" href="/assets/js/6.8c45e792.js"><link rel="prefetch" href="/assets/js/7.689677a5.js"><link rel="prefetch" href="/assets/js/8.598e5b67.js"><link rel="prefetch" href="/assets/js/9.9fd3d84b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.17f32d1e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Ryan Lin 的小书房</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="创建型模式"><a href="#创建型模式" class="header-anchor">#</a> 创建型模式</h1> <p>创建型模式的目的就是封装创建对象的变化</p> <p>这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。
这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</p> <ul><li>工厂模式（Factory Pattern）</li> <li>抽象工厂模式（Abstract Factory Pattern）</li> <li>单例模式（Singleton Pattern）</li> <li>建造者模式（Builder Pattern）</li> <li>原型模式（Prototype Pattern）</li></ul> <h2 id="单例模式"><a href="#单例模式" class="header-anchor">#</a> ** 单例模式 **</h2> <p>** 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 **</p> <h3 id="_1、实现单例模式"><a href="#_1、实现单例模式" class="header-anchor">#</a> 1、实现单例模式</h3> <p>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏 览器中的 window 对象等。
在 JavaScript 开发中，单例模式的用途同样非常广泛。
试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，
而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。</p> <div class="language- extra-class"><pre class="language-text"><code>  var CreateDiv = (function() {
    var instance;
    var CreateDiv = function(html) {
      if (instance) {
        return instance;
      }
      this.html = html;
      this.init();
      return (instance = this);
    };

    CreateDiv.prototype.init = function() {
      var div = document.createElement(&quot;div&quot;);
      div.innerHTML = this.html;
      document.body.appendChild(div);
    };

    return CreateDiv;
  })();

  var a = new CreateDiv(&quot;sven1&quot;);
  var b = new CreateDiv(&quot;sven2&quot;);
  alert(a === b); // true
</code></pre></div><p>为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回
真正的 Singleton 构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。</p> <div class="language- extra-class"><pre class="language-text"><code>var CreateDiv = function( html ){ 
  if ( instance ){
    return instance; 
  }
  this.html = html;
  this.init();
  return instance = this;
};
</code></pre></div><p>在这段代码中，CreateDiv 的构造函数实际上负责了两件事情。
第一是创建对象和执行初始化 init 方法，第二是保证只有一个对象。
不符合 “单一职责原则” 的概念， 可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。</p> <p>假设我们某天需要利用这个类，在页面中创建千千万万的 div，即要让这个类从单例类变成 一个普通的可产生多个实例的类，
那我们必须得改写 CreateDiv 构造函数，把控制创建唯一对象的那一段去掉，这种修改会给我们带来不必要的烦恼。</p> <h3 id="_2、用代理实现单例模式"><a href="#_2、用代理实现单例模式" class="header-anchor">#</a> 2、用代理实现单例模式</h3> <p>首先在 CreateDiv 构造函数中，把负责管理单例的代码移除出去，使它成为一个普通的创建 div 的类:</p> <div class="language- extra-class"><pre class="language-text"><code>    var CreateDiv = function( html ){
      this.html = html;
      this.init();
    };
    CreateDiv.prototype.init = function(){
      var div = document.createElement( 'div' ); 
      div.innerHTML = this.html; 
      document.body.appendChild( div );
    };
</code></pre></div><p>接下来引入代理类 proxySingletonCreateDiv:</p> <div class="language- extra-class"><pre class="language-text"><code>  var ProxySingletonCreateDiv = (function() {
    var instance;
    return function(html) {
      if (!instance) {
        instance = new CreateDiv(html);
      }
      return instance;
    };
  })();
  var a = new ProxySingletonCreateDiv(&quot;sven1&quot;);
  var b = new ProxySingletonCreateDiv(&quot;sven2&quot;);
  alert(a === b);
</code></pre></div><p>通过引入代理类的方式，我们同样完成了一个单例模式的编写，
跟之前不同的是，现在我们 把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。
这样一来，CreateDiv 就变成了 一个普通的类，它跟 proxySingletonCreateDiv 组合起来可以达到单例模式的效果。</p> <h3 id="_3、javascript-中的单例模式"><a href="#_3、javascript-中的单例模式" class="header-anchor">#</a> 3、JavaScript 中的单例模式</h3> <p>JavaScript 是一门无类语言，单例模式的核心是确保只有一个实例，并提供全局访问。</p> <p>全局变量不是单例模式，但在 JavaScript 开发中，我们经常会把全局变量当成单例来使用。
例如:</p> <p>var a = {};</p> <p>但是全局变量存在很多问题，它很容易造成命名空间污染。
在大中型项目中，如果不加以限 制和管理，程序中可能存在很多这样的变量。JavaScript 中的变量也很容易被不小心覆盖，
相信每个 JavaScript 程序员都曾经历过变量冲突的痛苦，就像上面的对象 var a = {};，随时有可能被 别人覆盖。</p> <ul><li>使用命名空间</li></ul> <p>适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。</p> <p>最简单的方法依然是用对象字面量的方式:</p> <div class="language- extra-class"><pre class="language-text"><code>  var namespace1 = { 
    a: function() { 
      alert (1);
    },
    b: function() {
      alert (2); 
    }
  };
</code></pre></div><p>把 a 和 b 都定义为 namespace1 的属性，这样可以减少变量和全局作用域打交道的机会。</p> <ul><li>使用闭包封装私有变量</li></ul> <p>这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信:</p> <div class="language- extra-class"><pre class="language-text"><code>  var user = (function() {
    var __name = &quot;sven&quot;,
      __age = 29;
    return {
      getUserInfo: function() {
        return __name + &quot;-&quot; + __age;
      }
    };
  })();
</code></pre></div><h3 id="_4、惰性单例"><a href="#_4、惰性单例" class="header-anchor">#</a> 4、惰性单例</h3> <p>惰性单例指的是在需要的时候才创建对象实例。</p> <div class="language- extra-class"><pre class="language-text"><code>  var createLoginLayer = (function() {
    var div;
    return function() {
      if (!div) {
        div = document.createElement(&quot;div&quot;);
        div.innerHTML = &quot;我是登录浮窗&quot;;
        div.style.display = &quot;none&quot;;
        document.body.appendChild(div);
      }
      return div;
    };
  })();

  document.getElementById(&quot;loginBtn&quot;).onclick = function() {
    var loginLayer = createLoginLayer();
    loginLayer.style.display = &quot;block&quot;;
  };
</code></pre></div><ul><li>通用的惰性单例</li></ul> <p>这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部。</p> <p>如果我们下次需要创建页面中唯一的 iframe，或者 script 标签，用来跨域请求数据，就必须得如法炮制，把 createLoginLayer 函数几乎照抄一遍</p> <p>现在我们就把如何管理单例的逻辑从原来的代码中抽离出来，
这些逻辑被封装在 getSingle 函数内部，创建对象的方法 fn 被当成参数动态传入 getSingle 函数:</p> <div class="language- extra-class"><pre class="language-text"><code>  var getSingle = function(fn) {
    var result;
    return function() {
      return result || (result = fn.apply(this, arguments));
    };
  };

  var createLoginLayer = function() {
    var div = document.createElement(&quot;div&quot;);
    div.innerHTML = &quot;我是登录浮窗&quot;;
    div.style.display = &quot;none&quot;;
    document.body.appendChild(div);
    return div;
  };

  var createSingleLoginLayer = getSingle(createLoginLayer);

  document.getElementById(&quot;loginBtn&quot;).onclick = function() {
    var loginLayer = createSingleLoginLayer();
    loginLayer.style.display = &quot;block&quot;;
  };
</code></pre></div><p>这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，
接下来要给这个列表绑定 click 事件，如果是通过 ajax 动态往列表里追加数据，在使用事件代理的前提
下，click 事件实际上只需要在第一次渲染列表的时候被绑定一次。</p> <p>利用 getSingle 函数，达到效果</p> <div class="language- extra-class"><pre class="language-text"><code>  var bindEvent = getSingle(function() {
    document.getElementById(&quot;div1&quot;).onclick = function() {
      alert(&quot;click&quot;);
    };
    return true;
  });

  var render = function() {
    console.log(&quot;开始渲染列表&quot;);
    bindEvent();
  };

  render();
  render();
  render();
</code></pre></div><p>// 可以看到，render 函数和 bindEvent 函数都分别执行了 3 次，但 div 实际上只被绑定了一个 事件。</p> <h2 id="原型模式-（原型）"><a href="#原型模式-（原型）" class="header-anchor">#</a> ** 原型模式 （原型）**</h2> <p>** 对象把 <code>__proto__</code> 委托给构造器的原型 **</p> <p>JavaScript 给对象提供了一个名为 <code>__proto__</code> 的隐藏属性， 某个对象的 <code>__proto__</code> 默认会指向它的构造函数的原型对象，
即 <code>(Constructor).prototype</code>。</p> <p>在一些浏览器会暴露出来, 比如谷歌:</p> <div class="language- extra-class"><pre class="language-text"><code>  var a = new Object();
  console.log(a.__proto__ === Object.prototype)
</code></pre></div><p>可以通过原型访问当前对象没有的属性，当 <code>Object.prototype</code> 也没有该属性的时候，
它会像 Object.prototype 的原型上找，但是 Object.prototype 的原型是 <code>null</code>，
说明这时候原型链后面已经没有其他原型了，这时候会返回 undefined。</p> <p>当通过 Object.create(null) 可以创建出没有原型的对象。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7b557cf4.js" defer></script><script src="/assets/js/2.9d2502b9.js" defer></script><script src="/assets/js/15.581d44ad.js" defer></script>
  </body>
</html>
