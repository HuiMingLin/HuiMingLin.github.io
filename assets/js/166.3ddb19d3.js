(window.webpackJsonp=window.webpackJsonp||[]).push([[166],{523:function(e,t,v){"use strict";v.r(t);var r=v(25),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),v("p",[e._v("生命周期（Life Cycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程")]),e._v(" "),v("p",[e._v("在Vue中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程")]),e._v(" "),v("p",[e._v("我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作")]),e._v(" "),v("p",[e._v("PS：在Vue生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () => this.fetchTodos())")]),e._v(" "),v("h2",{attrs:{id:"分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[e._v("#")]),e._v(" 分类")]),e._v(" "),v("p",[e._v("Vue生命周期总共可以分为8个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期")]),e._v(" "),v("table",[v("thead",[v("tr",[v("th",[e._v("生命周期")]),e._v(" "),v("th",[e._v("描述")])])]),e._v(" "),v("tbody",[v("tr",[v("td",[e._v("beforeCreate")]),e._v(" "),v("td",[e._v("组件实例被创建之初,执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务")])]),e._v(" "),v("tr",[v("td",[e._v("created")]),e._v(" "),v("td",[e._v("组件实例已经完全创建,组件初始化完毕，各种数据可以使用，常用于异步数据获取")])]),e._v(" "),v("tr",[v("td",[e._v("beforeMount")]),e._v(" "),v("td",[e._v("组件挂载之前,未执行渲染、更新，dom未创建")])]),e._v(" "),v("tr",[v("td",[e._v("mounted")]),e._v(" "),v("td",[e._v("组件挂载到实例上去之后,初始化结束，dom已创建，可用于获取访问数据和dom元素")])]),e._v(" "),v("tr",[v("td",[e._v("beforeUpdate")]),e._v(" "),v("td",[e._v("组件数据发生变化，更新之前,更新前，可用于获取更新前各种状态")])]),e._v(" "),v("tr",[v("td",[e._v("updated")]),e._v(" "),v("td",[e._v("组件数据更新之后,更新后，所有状态已是最新")])]),e._v(" "),v("tr",[v("td",[e._v("beforeDestroy")]),e._v(" "),v("td",[e._v("组件实例销毁之前,销毁前，可用于一些定时器或订阅的取消")])]),e._v(" "),v("tr",[v("td",[e._v("destroyed")]),e._v(" "),v("td",[e._v("组件实例销毁之后,组件已销毁，作用同上")])]),e._v(" "),v("tr",[v("td",[e._v("activated")]),e._v(" "),v("td",[e._v("keep-alive 缓存的组件激活时")])]),e._v(" "),v("tr",[v("td",[e._v("deactivated")]),e._v(" "),v("td",[e._v("keep-alive 缓存的组件停用时调用")])]),e._v(" "),v("tr",[v("td",[e._v("errorCaptured")]),e._v(" "),v("td",[e._v("捕获一个来自子孙组件的错误时被调用")])])])]),e._v(" "),v("h2",{attrs:{id:"整体流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#整体流程"}},[e._v("#")]),e._v(" 整体流程")]),e._v(" "),v("p",[v("img",{attrs:{src:"/assets/img/vue/lifecycle.png",alt:"alt 属性文本"}})]),e._v(" "),v("h3",{attrs:{id:"beforecreate-created"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#beforecreate-created"}},[e._v("#")]),e._v(" beforeCreate -> created")]),e._v(" "),v("p",[e._v("初始化vue实例，进行数据观测")]),e._v(" "),v("h3",{attrs:{id:"created"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#created"}},[e._v("#")]),e._v(" created")]),e._v(" "),v("ul",[v("li",[e._v("完成数据观测，属性与方法的运算，watch、event事件回调的配置")]),e._v(" "),v("li",[e._v("可调用methods中的方法，访问和修改data数据触发响应式渲染dom，可通过computed和watch完成数据计算")]),e._v(" "),v("li",[e._v("此时vm.$el 并没有被创建")])]),e._v(" "),v("h3",{attrs:{id:"created-beforemount"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#created-beforemount"}},[e._v("#")]),e._v(" created -> beforeMount")]),e._v(" "),v("ul",[v("li",[e._v("判断是否存在el选项，若不存在则停止编译，直到调用vm.$mount(el)才会继续编译")]),e._v(" "),v("li",[e._v("优先级：render > template > outerHTML")]),e._v(" "),v("li",[e._v("vm.el获取到的是挂载DOM的")])]),e._v(" "),v("h3",{attrs:{id:"beforemount"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#beforemount"}},[e._v("#")]),e._v(" beforeMount")]),e._v(" "),v("ul",[v("li",[e._v("在此阶段可获取到vm.el")]),e._v(" "),v("li",[e._v("此阶段vm.el虽已完成DOM初始化，但并未挂载在el选项上")])]),e._v(" "),v("h3",{attrs:{id:"beforemount-mounted"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#beforemount-mounted"}},[e._v("#")]),e._v(" beforeMount -> mounted")]),e._v(" "),v("p",[e._v("此阶段vm.el完成挂载，vm.$el生成的DOM替换了el选项所对应的DOM")]),e._v(" "),v("h3",{attrs:{id:"mounted"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mounted"}},[e._v("#")]),e._v(" mounted")]),e._v(" "),v("p",[e._v("vm.el已完成DOM的挂载与渲染，此刻打印vm.$el，发现之前的挂载点及内容已被替换成新的DOM")]),e._v(" "),v("h3",{attrs:{id:"beforeupdate"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#beforeupdate"}},[e._v("#")]),e._v(" beforeUpdate")]),e._v(" "),v("ul",[v("li",[e._v("更新的数据必须是被渲染在模板上的（el、template、render之一）")]),e._v(" "),v("li",[e._v("此时view层还未更新")]),e._v(" "),v("li",[e._v("若在beforeUpdate中再次修改数据，不会再次触发更新方法")])]),e._v(" "),v("h3",{attrs:{id:"updated"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#updated"}},[e._v("#")]),e._v(" updated")]),e._v(" "),v("ul",[v("li",[e._v("完成view层的更新")]),e._v(" "),v("li",[e._v("若在updated中再次修改数据，会再次触发更新方法（beforeUpdate、updated）")])]),e._v(" "),v("h3",{attrs:{id:"beforedestroy"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#beforedestroy"}},[e._v("#")]),e._v(" beforeDestroy")]),e._v(" "),v("p",[e._v("实例被销毁前调用，此时实例属性与方法仍可访问")]),e._v(" "),v("h3",{attrs:{id:"destroyed"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#destroyed"}},[e._v("#")]),e._v(" destroyed")]),e._v(" "),v("ul",[v("li",[e._v("完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器")]),e._v(" "),v("li",[e._v("并不能清除DOM，仅仅销毁实例")])]),e._v(" "),v("h2",{attrs:{id:"数据请求在created和mouted的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据请求在created和mouted的区别"}},[e._v("#")]),e._v(" 数据请求在created和mouted的区别")]),e._v(" "),v("p",[e._v("created是在组件实例一旦创建完成的时候立刻调用，这时候页面dom节点并未生成；")]),e._v(" "),v("p",[e._v("mounted是在页面dom节点渲染完毕之后就立刻执行的。触发时机上created是比mounted要更早的，")]),e._v(" "),v("p",[e._v("两者的相同点：都能拿到实例对象的属性和方法。")]),e._v(" "),v("p",[e._v("讨论这个问题本质就是触发的时机，放在mounted中的请求有可能导致页面闪动（因为此时页面dom结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在created生命周期当中。")])])}),[],!1,null,null,null);t.default=a.exports}}]);