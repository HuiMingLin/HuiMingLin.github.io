(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{212:function(e,t,a){"use strict";a.r(t);var r=a(0),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"es6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6"}},[e._v("#")]),e._v(" ES6")]),e._v(" "),a("h2",{attrs:{id:"let-和-const"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#let-和-const"}},[e._v("#")]),e._v(" let 和 const")]),e._v(" "),a("h2",{attrs:{id:"箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[e._v("#")]),e._v(" 箭头函数 =>")]),e._v(" "),a("p",[e._v("因为箭头函数没有 this，所以也就不能用作构造函数。")]),e._v(" "),a("h2",{attrs:{id:"数据类型转化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型转化"}},[e._v("#")]),e._v(" 数据类型转化")]),e._v(" "),a("h2",{attrs:{id:"模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[e._v("#")]),e._v(" 模块化")]),e._v(" "),a("p",[e._v("优点：")]),e._v(" "),a("ul",[a("li",[e._v("解决命名冲突")]),e._v(" "),a("li",[e._v("代码的复用性")]),e._v(" "),a("li",[e._v("提高代码可维护性")])]),e._v(" "),a("h3",{attrs:{id:"立即执行函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#立即执行函数"}},[e._v("#")]),e._v(" 立即执行函数")]),e._v(" "),a("p",[e._v("在早期，使用立即执行函数实现模块化是常见的手段，\n通过函数作用域解决了命名冲突、污染全局作用域的问题")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  (function(globalVariable){\n    globalVariable.test = function() {}\n    // ... 声明各种变量、函数都不会污染全局作用域\n  })(globalVariable)\n")])])]),a("h3",{attrs:{id:"amd-和-cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#amd-和-cmd"}},[e._v("#")]),e._v(" AMD 和 CMD")]),e._v(" "),a("p",[e._v("鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  // AMD\n  define(['./a', './b'], function(a, b) {\n    // 加载模块完毕可以使用\n    a.do()\n    b.do()\n  })\n  // CMD\n  define(function(require, exports, module) {\n    // 加载模块\n    // 可以把 require 写在函数体的任意地方实现延迟加载\n    var a = require('./a')\n    a.doSomething()\n  })\n")])])]),a("h3",{attrs:{id:"commonjs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[e._v("#")]),e._v(" CommonJS")]),e._v(" "),a("p",[e._v("CommonJS 最早是 Node 在使用，目前也仍然广泛使用，\n比如在 Webpack 中你就能见到它，\n当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  // a.js\n  module.exports = {\n      a: 1\n  }\n  // or \n  exports.a = 1\n\n  // b.js\n  var module = require('./a.js')\n  module.a // -> log 1\n")])])]),a("p",[e._v("因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析")]),e._v(" "),a("p",[e._v("先说 "),a("code",[e._v("require")]),e._v(" 吧")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  var module = require('./a.js')\n  module.a \n  // 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，\n  // 重要的是 module 这里，module 是 Node 独有的一个变量\n  module.exports = {\n      a: 1\n  }\n\n  // module 基本实现\n  var module = {\n    id: 'xxxx', // 我总得知道怎么去找到他吧\n    exports: {} // exports 就是个空对象\n  }\n\n  // 这个是为什么 exports 和 module.exports 用法相似的原因\n  var exports = module.exports \n  var load = function (module) {\n      // 导出的东西\n      var a = 1\n      module.exports = a\n      return module.exports\n  };\n  // 然后当我 require 的时候去找到独特的\n  // id，然后将要使用的东西用立即执行函数包装下，over\n")])])]),a("p",[e._v("另外虽然 "),a("code",[e._v("exports")]),e._v(" 和 "),a("code",[e._v("module.exports")]),e._v(" 用法相似，但是不能对 exports 直接赋值。\n因为 "),a("code",[e._v("var exports = module.exports")]),e._v(" 这句代码表明了 exports 和 module.exports 享有相同地址，通过改变对象的属性值会对两者都起效，\n但是如果直接对 "),a("code",[e._v("exports")]),e._v(" 赋值就会导致两者不再指向同一个内存地址，修改并不会对 "),a("code",[e._v("module.exports")]),e._v(" 起效。")]),e._v(" "),a("h3",{attrs:{id:"es-module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es-module"}},[e._v("#")]),e._v(" ES Module")]),e._v(" "),a("p",[e._v("ES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别")]),e._v(" "),a("ul",[a("li",[e._v("CommonJS 支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案")]),e._v(" "),a("li",[e._v("CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。\n而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响")]),e._v(" "),a("li",[e._v("CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。\n但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化")]),e._v(" "),a("li",[e._v("ES Module 会编译成 require/exports 来执行的")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  // 引入模块 API\n  import XXX from './a.js'\n  import { XXX } from './a.js'\n  // 导出模块 API\n  export function a() {}\n  export default function() {}\n")])])]),a("h2",{attrs:{id:"proxy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy"}},[e._v("#")]),e._v(" Proxy")]),e._v(" "),a("p",[e._v("如果你平时有关注 Vue 的进展的话，\n可能已经知道了在 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。\nProxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  let p = new Proxy(target, handler)\n")])])]),a("h2",{attrs:{id:"promise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),a("p",[e._v("promise/A+ "),a("a",{attrs:{href:"http://www.ituring.com.cn/article/66566",target:"_blank",rel:"noopener noreferrer"}},[e._v("规范"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步"}},[e._v("#")]),e._v(" 异步")]),e._v(" "),a("p",[e._v("事件队列 "),a("code",[e._v("宏任务（macro-task）")]),e._v("” 和 "),a("code",[e._v("微任务（micro-task)")])]),e._v(" "),a("p",[e._v("macrotask 和 microtask 两个概念，这表示异步任务的两种分类。\n在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，\n首先在 macrotask 的队列（这个队列也被叫做 task queue）中取出第一个任务，\n执行完毕后取出 microtask 队列中的所有任务顺序执行；\n之后再取 macrotask 任务，周而复始，直至两个队列的任务都取完。")]),e._v(" "),a("p",[e._v("两个类别的具体分类如下：")]),e._v(" "),a("p",[e._v("macro-task: script（整体代码）, setTimeout, setInterval, setImmediate, I/O, UI rendering\nmicro-task: process.nextTick, Promises（这里指浏览器实现的原生 Promise）, Object.observe, MutationObserver")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://mp.weixin.qq.com/s/mT5XvdMnlw0Qt8EBvgDtYQ",target:"_blank",rel:"noopener noreferrer"}},[e._v("教程"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);