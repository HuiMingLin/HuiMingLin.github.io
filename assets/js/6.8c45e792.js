(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{227:function(n,a,e){"use strict";e.r(a);var t=e(0),l=Object(t.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("** 闭包的形成与变量的作用域以及变量的生存周期密切相关 **")]),n._v(" "),e("h2",{attrs:{id:"作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[n._v("#")]),n._v(" 作用域")]),n._v(" "),e("h3",{attrs:{id:"全局作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全局作用域"}},[n._v("#")]),n._v(" 全局作用域")]),n._v(" "),e("p",[n._v("在这个作用域上创建的变量，都会挂载到 window 上， 成为全局变量，也是最外层的作用域。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var globalA = 'globalA';\n  var globalB = \"globalB\";\n\n  var add = function (a, b) {\n    return a + b;\n  }\n")])])]),e("h3",{attrs:{id:"函数作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[n._v("#")]),n._v(" 函数作用域")]),n._v(" "),e("p",[n._v("当创建一个函数时，通过 "),e("code",[n._v("var")]),n._v(" 创建的变量都是该函数的局部变量, 在函数外部是访问不到的，在函数调用之后这些变量会被垃圾回收机制回收。\n但是当创建变量不通过 "),e("code",[n._v("var")]),n._v(" 时，创建的变量会变成全局变量。全局变量是不会被回收的，除非关闭浏览器或者手动删除该属性。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var globalA = 'globalA';\n  var add = function (a, b) {\n    globalA = 'globalB';\n    var addA = 'add';\n    return a + b;\n  }\n  console.log(window.globalA); // globalA\n  add()\n  console.log(window.globalA); // globalB\n  console.log(addA) // Uncaught ReferenceError: addA is not defined\n")])])]),e("h3",{attrs:{id:"块作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#块作用域"}},[n._v("#")]),n._v(" 块作用域")]),n._v(" "),e("p",[n._v("块作用域是 ES6 添加的，ES5之前是没有块作用域的。")]),n._v(" "),e("p",[n._v("举个例子：")]),n._v(" "),e("ul",[e("li",[n._v("html")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n    <li>6</li>\n    <li>7</li>\n    <li>8</li>\n    <li>9</li>\n    <li>9</li>\n")])])]),e("ul",[e("li",[n._v("js")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    var lis = document.getElementsByTagName('li');\n    var len = lis.length;\n    \n    for (var i = 0; i < len; i++) {\n      lis[i].onclick = function () {\n        console.log(i); // 点击任意一个都输出 9\n      }\n    }\n    console.log(window.i); // 9\n")])])]),e("p",[n._v("这是因为 li 节点的 onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，\n此时变量 i 的值已经是 9，所以在 li 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 9,\n可以通过 "),e("code",[n._v("let")]),n._v(" 和 "),e("code",[n._v("闭包")]),n._v(" 解决。")]),n._v(" "),e("p",[n._v("因为 ES6 之前没有块作用域， 所以变量 "),e("code",[n._v("i")]),n._v(" 会成为全局变量，可以通过 "),e("code",[n._v("window.i")]),n._v(" 访问。")]),n._v(" "),e("p",[n._v("在 ES6 中通过 "),e("code",[n._v("let")]),n._v(" 代替 var 声明变量，实现块作用域。")]),n._v(" "),e("ul",[e("li",[n._v("js")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("    let lis = document.getElementsByTagName('li');\n    let len = lis.length;\n    \n    for (let i = 0; i < len; i++) {\n      lis[i].onclick = function () {\n        console.log(i);\n      }\n    }\n    console.log(window.i); // undefined\n")])])]),e("h2",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[n._v("#")]),n._v(" 闭包")]),n._v(" "),e("p",[n._v("访问变量的顺序")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var name = 'ryan'\n  var getName = function () {\n    return name;\n  }\n  console.log(getName()) // ryan\n\n\n  var name = 'ryan'\n  var getName = function () {\n    var name = 'sally'\n    return name;\n  }\n  console.log(getName()) // sally\n\n  var name = 'ryan'\n  var getName = function () {\n    var name = 'sally'\n    return function () {\n      return name;\n    };\n  }\n  console.log(getName()) // sally\n\n  var name = 'ryan'\n  var getName = function () {\n    var name = 'sally'\n    return function () {\n      var name = 'marry'\n      return name;\n    };\n  }\n  console.log(getName()) // marry\n")])])]),e("p",[n._v("在函数作用域中，最内层的函数可以访问它的上一层函数的作用域（变量和内部函数），直至全局作用域。\n当访问一个最内层函数没有的变量时，就会往上一层找，直至找到或者undefined。")]),n._v(" "),e("p",[n._v("闭包就是通过函数作用域创建一个函数，为某个作用域创建一个独立作用域, 并且返回一个函数。\n在闭包的帮助下，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var lis = document.getElementsByTagName('li');\n  var len = lis.length;\n    \n  for (var i = 0; i < len; i++) {\n    lis[i].onclick = (function (i) {\n      return function () {\n        console.log(i);\n      }\n    })(i)\n  }\n  console.log(window.i); // 9\n")])])]),e("p",[n._v("这样当点击 li 的时候，会访问 "),e("code",[n._v("IIFE")]),n._v(" 创建的那个作用域，而且我们将 for 循环的 i 作为参数传入到 IIFE 中。")]),n._v(" "),e("p",[n._v("再看一下另外一种写法：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var clickFn = function (i) {\n    // 这个作用域里有一个变量 i\n    return function () {\n      console.log(i);\n    }\n  }\n\n  for (var i = 0; i < len; i++) {\n    lis[i].onclick = clickFn(i)\n  }\n  console.log(window.i); // 9\n")])])]),e("p",[n._v("都是为了能为每一个 li 的绑定事件函数传入不同的 i。")]),n._v(" "),e("p",[n._v("按照 "),e("code",[n._v("JavaScript引擎")]),n._v(" 函数在调用完成之后变量会被垃圾回收机制回收，那为什么我们访问输出 i 的时候，好像变量 i 没有消失呢？\n这是闭包的另外一个能力。")]),n._v(" "),e("p",[n._v("除了保证每次传入的都是唯一并且不同的值，并且这个变量不会被回收，因为当你点击 li 的时候所调用的函数需要变量 i，\n"),e("code",[n._v("JavaScript引擎")]),n._v(" 发现被调用的函数里没有变量 i， 只能通过作用域一层层往上找， 所以找到了被当做参数的变量 i。\n发现变量 i 还需要被用到，所以不会被回收。而且这个函数作用域里的其他的变量也是可以访问，这在之前说过。")]),n._v(" "),e("h2",{attrs:{id:"闭包更多作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包更多作用"}},[n._v("#")]),n._v(" 闭包更多作用")]),n._v(" "),e("ul",[e("li",[n._v("封装变量")])]),n._v(" "),e("p",[n._v("假如我们写一个库， 里面包含了两个函数。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var add = function (a, b) {\n    return a + b;\n  }  \n  var multiply = function (a, b) {\n    return a * b;\n  }  \n")])])]),e("p",[n._v("当别人引用这个库的时候，别人的代码里也有这两个函数的时候，这时候函数会被覆盖。\n所以我们用一个全局变量来存储它，并且通过闭包使这两个函数只能通过内部访问，\n减少全局变量的污染。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var R = (function () {\n    var add = function (a, b) {\n      return a + b;\n    }  \n    var multiply = function (a, b) {\n      return a * b;\n    }  \n\n    return {\n      add: add,\n      multiply: multiply\n    } \n  })()\n")])])]),e("p",[n._v("这下我们将函数只能 R 内部访问，并且暴露出一个 全局变量 R。")]),n._v(" "),e("ul",[e("li",[n._v("延续局部变量的寿命")])]),n._v(" "),e("p",[n._v("img 对象经常用于进行数据上报，如下所示:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var report = function( src )   { \n    var img = new Image();\n    img.src = src;\n  };\n\n  report( 'http://xxx.com/getUserInfo' );\n")])])]),e("p",[n._v("但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，\n在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据。")]),n._v(" "),e("p",[n._v("也就是说，report 函数并不是每一次 都成功发起了 HTTP 请求。\n丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的 调用结束后，img 局部变量随即被销毁，\n而此时或许还没来得及发出 HTTP 请求，所以此次请求 就会丢失掉。")]),n._v(" "),e("p",[n._v("现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题:")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var report = (function(){ var imgs = [];\n    return function(src){\n    var img = new Image(); \n    imgs.push( img ); \n    img.src = src;\n  }})();\n")])])]),e("h2",{attrs:{id:"闭包造成的内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包造成的内存泄漏"}},[n._v("#")]),n._v(" 闭包造成的内存泄漏")]),n._v(" "),e("p",[n._v("闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。")]),n._v(" "),e("p",[n._v("局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。\n从这个意义上看，闭包的确会使一些数据无法被及时销毁。\n使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，\n因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。\n如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。")])])}),[],!1,null,null,null);a.default=l.exports}}]);