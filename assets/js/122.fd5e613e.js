(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{480:function(e,t,o){"use strict";o.r(t);var r=o(25),a=Object(r.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"react-memo"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react-memo"}},[e._v("#")]),e._v(" react.memo")]),e._v(" "),o("p",[e._v("React.memo是React中的一个高阶组件（Higher-Order Component），用于优化组件的渲染性能。React.memo可以用于包裹函数组件，用于对组件进行浅层的props比较，如果前后props没有变化，则会使用缓存的组件渲染结果。")]),e._v(" "),o("p",[e._v("React.memo适合用在以下场景下：")]),e._v(" "),o("ul",[o("li",[e._v("当组件的渲染开销较大，但组件的props没有变化时，可以使用React.memo进行性能优化，避免不必要的重新渲染。")]),e._v(" "),o("li",[e._v("当组件的props是通过父组件传递的，而父组件的渲染频率较高，但子组件的props并不频繁变化时，可以使用React.memo来避免子组件的重复渲染。")])]),e._v(" "),o("p",[e._v("需要注意的是，React.memo仅进行浅层的props比较，如果传递给组件的props是复杂的对象或数组，且其内部发生了变化，React.memo可能无法正确地检测到变化。在这种情况下，可以考虑使用深层比较或Immutable数据结构来确保正确的比较和渲染。")])])}),[],!1,null,null,null);t.default=a.exports}}]);