(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{464:function(e,t,a){"use strict";a.r(t);var s=a(25),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[a("img",{attrs:{src:"/assets/img/load-time.png",alt:"alt 属性文本"}})]),e._v(" "),a("h1",{attrs:{id:"概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[e._v("#")]),e._v(" 概念")]),e._v(" "),a("p",[e._v("白屏和首屏")]),e._v(" "),a("p",[e._v("白屏时间 = 地址栏输入网址后回车 - 浏览器出现第一个元素")]),e._v(" "),a("p",[e._v("首屏时间 = 地址栏输入网址后回车 - 浏览器第一屏渲染完成")]),e._v(" "),a("p",[e._v("根据白屏和首屏的定义，我们可以用FP和FCP来计算白屏和首屏。")]),e._v(" "),a("p",[e._v("白屏结束时间 = FP事件触发时间")]),e._v(" "),a("p",[e._v("首屏结束时间 = FCP事件触发时间")]),e._v(" "),a("p",[e._v("当然FCP代表第一个内容被渲染出来，有些业务中希望用更关键的内容的渲染来表示首屏，这时候可以用FMP或者LCP来作为首屏的计算指标。")]),e._v(" "),a("h2",{attrs:{id:"longtask"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#longtask"}},[e._v("#")]),e._v(" longTask")]),e._v(" "),a("p",[e._v("阻塞主线程达 50 毫秒或以上的任务，会导致以下问题：")]),e._v(" "),a("ul",[a("li",[e._v("可交互时间延迟")]),e._v(" "),a("li",[e._v("严重不稳定的交互行为 (轻击、单击、滚动、滚轮等) 延迟（High/variable input latency）")]),e._v(" "),a("li",[e._v("严重不稳定的事件回调延迟（High/variable event handling latency）")]),e._v(" "),a("li",[e._v("紊乱的动画和滚动（Janky animations and scrolling）")])]),e._v(" "),a("p",[e._v("任何连续不间断的且主 UI 线程繁忙 50 毫秒及以上的时间区间。比如以下常规场景：")]),e._v(" "),a("ul",[a("li",[e._v("长耗时的事件回调（long running event handlers）")]),e._v(" "),a("li",[e._v("代价高昂的回流和其他重绘（expensive reflows and other re-renders）")]),e._v(" "),a("li",[e._v("浏览器在超过 50 毫秒的事件循环的相邻循环之间所做的工作")])]),e._v(" "),a("p",[e._v("可以通过PerformanceObserver获取。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    console.log('longtask candidate: ', entry.startTime);\n  }\n});\n\nobserver.observe({entryTypes: ['longtask']});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("h2",{attrs:{id:"resource-timing-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#resource-timing-api"}},[e._v("#")]),e._v(" Resource Timing API")]),e._v(" "),a("p",[e._v("通过 Resource Timing API 可以获取和分析应用资源加载的详细网络计时数据，应用程序可以使用时间度量标准来确定加载特定资源所需要的时间，比如 XMLHttpRequest、SVG、图片或者脚本。")]),e._v(" "),a("p",[e._v("Resource Timing API 为网络事件（如重定向的开始和结束事件、DNS 查找的开始和结束事件、请求开始、响应开始和结束时间等）生成有高分辨率时间戳（high-resolution timestamp）的资源加载时间线，并提供了资源大小和资源类型。")]),e._v(" "),a("h3",{attrs:{id:"高分辨率时间戳"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高分辨率时间戳"}},[e._v("#")]),e._v(" 高分辨率时间戳")]),e._v(" "),a("p",[e._v("代表了高分辨率的时间点。高分辨率时间戳类型是 DOMHighResTimeStamp，用双精度数字（double）表示，它的值是一个离散的时间点或者两个离散时间点之间的时间差。")]),e._v(" "),a("p",[e._v("DOMHighResTimeStamp 的单位是毫秒（ms），并且应该可以准确到 5 微秒（µs）。但是，如果浏览器无法以提供精确到 5 微秒的时间值（如软硬件限制），则可以将该值表示为以毫秒为单位的精确到毫秒的时间。")]),e._v(" "),a("h3",{attrs:{id:"资源载入时间戳"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源载入时间戳"}},[e._v("#")]),e._v(" 资源载入时间戳")]),e._v(" "),a("p",[e._v("应用程序可以获得用于加载资源的各个阶段的时间戳。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("startTime：在资源加载过程开始之前立即返回时间")])]),e._v(" "),a("li",[a("p",[e._v("fetchStart：跟踪和重定向处理（如果适用），并在 DNS 查找之前进行。")])]),e._v(" "),a("li",[a("p",[e._v("connectStart、 connectEnd：分别是开始连接到服务器和连接建立完成的时间戳。")]),e._v(" "),a("p",[e._v("如果资源是通过安全连接加载的 secureConnectionStart 的值将会在 connectStart 和 connectEnd 之间。")])]),e._v(" "),a("li",[a("p",[e._v("requestStart: 在浏览器开始向服务器请求资源时")])]),e._v(" "),a("li",[a("p",[e._v("responseStart: 资源请求首包返回时")])]),e._v(" "),a("li",[a("p",[e._v("responseEnd: 资源全部接收完成时。")])])]),e._v(" "),a("p",[e._v("在非 web 页面本身的域名下，这些属性在默认都会返回 0 值：redirectStart、redirectEnd、domainLookupStart、domainLookupEnd、connectStart、connectEnd、secureConnectionStart、requestStart 和 responseStart。")]),e._v(" "),a("p",[e._v("需要提供资源的服务器发送 Timing-Allow-Origin HTTP 响应标头并且指定 origin[s] 来源才能允许获取这些被限制的时间戳。")]),e._v(" "),a("h3",{attrs:{id:"典型的资源计时指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#典型的资源计时指标"}},[e._v("#")]),e._v(" 典型的资源计时指标")]),e._v(" "),a("ul",[a("li",[e._v("测量 TCP 握手时间（connectEnd - connectStart）")]),e._v(" "),a("li",[e._v("测量 DNS 查找时间（domainLookupEnd - domainLookupStart）")]),e._v(" "),a("li",[e._v("测量重定向时间（redirectEnd - redirectStart）")]),e._v(" "),a("li",[e._v("测量临时请求时间（firstInterimResponseStart - requestStart）")]),e._v(" "),a("li",[e._v("测量请求时间（responseStart - requestStart）")]),e._v(" "),a("li",[e._v("测量 TLS 协商时间（requestStart - secureConnectionStart）")]),e._v(" "),a("li",[e._v("测量获取时间（无重定向）（responseEnd - fetchStart）")]),e._v(" "),a("li",[e._v("测量 ServiceWorker 处理时间（fetchStart - workerStart）")]),e._v(" "),a("li",[e._v("检查内容是否被压缩（decodedBodySize 不应编码BodySize）")]),e._v(" "),a("li",[e._v("检查本地缓存是否命中（transferSize 应为 0）")]),e._v(" "),a("li",[e._v("检查是否使用现代且快速的协议（nextHopProtocol 应为 HTTP/2 或 HTTP/3）")]),e._v(" "),a("li",[e._v("检查正确的资源是否处于渲染阻塞状态 (renderBlockingStatus)")])]),e._v(" "),a("h2",{attrs:{id:"加载、渲染性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加载、渲染性能"}},[e._v("#")]),e._v(" 加载、渲染性能")]),e._v(" "),a("h3",{attrs:{id:"load"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#load"}},[e._v("#")]),e._v(" load")]),e._v(" "),a("p",[e._v("load 事件在整个页面及其所有外部资源（如图像、样式表、脚本等，不包括setTimeout加载的资源）加载完成后触发。这意味着页面的所有内容已经可用，并且可以执行与页面渲染和交互相关的操作。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// load\n// loadEventStart是load事件发送给文档，也即load回调函数开始执行的时间\n// loadEventEnd是load回调函数执行完成的时间\nconst loadTime = performance.timing.loadEventStart - performance.timing.fetchStart\n  const l = performance.timing.loadEventEnd - performance.timing.navigationStart;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("h3",{attrs:{id:"dcl-domcontentloaded"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dcl-domcontentloaded"}},[e._v("#")]),e._v(" DCL（DOMContentLoaded）")]),e._v(" "),a("p",[e._v("DOM解析完毕")]),e._v(" "),a("p",[e._v("如果页面有很多外部资源需要加载，那么load 事件会后触发，如果页面内容较多，外部资源较少，那么load事件先触发。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const dcl = performance.timing.domContentLoadedEventEnd - performance.timing.domContentLoadedEventStart\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"fp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fp"}},[e._v("#")]),e._v(" FP")]),e._v(" "),a("p",[e._v("渲染出第一个像素点。FP一般在HTML解析完成或者解析一部分时候触发。")]),e._v(" "),a("p",[e._v("当需要渲染的节点数少的时候，DCL会在FP前面；当需要渲染的节点数很多时候，DCL会在FP后面。")]),e._v(" "),a("p",[e._v("有节点不一定有渲染，如果"),a("strong",[e._v("没有任何样式，或者没有任何内容")]),e._v("，是没有界面的，也不需要渲染，就没有 FP 事件")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const fp = performance.getEntries('paint').filter(entry => entry.name == 'first-paint')[0].startTime;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"fcp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fcp"}},[e._v("#")]),e._v(" FCP")]),e._v(" "),a("p",[e._v('渲染出第一个内容，这里的"内容"可以是文本、图片、canvas。')]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const fcp = performance.getEntries('paint').filter(entry => entry.name == 'first-contentful-paint')[0].startTime;\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("FCP 性能值：首次内容绘制完成渲染时间应控制在 1.8s 以内。")]),e._v(" "),a("p",[e._v("我们可以从以下方向点优化 FCP ：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("消除阻塞渲染的资源：")])]),e._v(" "),a("li",[a("p",[e._v("script 标签：在 head 标签内的，并且没有 defer/async 属性")])]),e._v(" "),a("li",[a("p",[e._v('link 标签：没有 disabled 属性，有 media="all" 属性被认为是渲染阻塞')])]),e._v(" "),a("li",[a("p",[e._v("缩小 CSS 体积：写法，压缩 CSS")])]),e._v(" "),a("li",[a("p",[e._v("移除未使用的 CSS")])]),e._v(" "),a("li",[a("p",[e._v("预连接到所需的来源：link 的 preconnect")])]),e._v(" "),a("li",[a("p",[e._v("减少服务器响应时间（TTFB）")])]),e._v(" "),a("li",[a("p",[e._v("避免多个页面重定向：浏览器请求已定向的资源时，服务器会返回一个 HTTP 响应，然后浏览器必须在新位置发出另一个 HTTP 请求来检索资源。这种额外的网络传输会使资源加载延迟数百毫秒。")])]),e._v(" "),a("li",[a("p",[e._v("预加载关键请求：link 的 preload")])]),e._v(" "),a("li",[a("p",[e._v("避免巨大的网络负载：网络负载的中位数在 1700 到 1900 KiB 之间。 Lighthouse 会标记总网络请求超过 5000 KiB 的页面。将总字节大小保持在 1600 KiB 以下。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("缩小和压缩网络有效负载：缩小（代码），数据压缩（Gzip，Brotli）")])]),e._v(" "),a("li",[a("p",[e._v("图片使用 Webp")])]),e._v(" "),a("li",[a("p",[e._v("JPEG 图片压缩级别设置为 85")])])])]),e._v(" "),a("li",[a("p",[e._v("对静态资源使用高效的缓存策略：可缓存资源")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("字体、图像、媒体文件、脚本或样式表")])]),e._v(" "),a("li",[a("p",[e._v("资源具有 200 、 203 、 206 HTTP 状态码")])]),e._v(" "),a("li",[a("p",[e._v("资源没有明确的无缓存策略")])])])]),e._v(" "),a("li",[a("p",[e._v("避免 DOM 过大：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("会造成网络效率和负载性能差")])]),e._v(" "),a("li",[a("p",[e._v("页面交互时，会导致重新计算节点的位置和样式，降低渲染速度")])]),e._v(" "),a("li",[a("p",[e._v("可能会不知不觉存储大量节点的引用，造成内存过大")])])])]),e._v(" "),a("li",[a("p",[e._v("最小化关键请求深度：链的长度越长，下载量越大，对页面加载性能的影响就越大")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("减少关键资源数量（删除，推迟下载，标记 async 等）")])]),e._v(" "),a("li",[a("p",[e._v("优化关键字节数减少下载时间")])]),e._v(" "),a("li",[a("p",[e._v("优化剩余关键资源的加载顺序，尽早下载所有关键资源，缩短关键路径长度")])])])]),e._v(" "),a("li",[a("p",[e._v("确保文本在网页字体加载期间保持可见：预加载网络字体")])]),e._v(" "),a("li",[a("p",[e._v("保持较低的请求数和较小的传输大小： CSS 和 JavaScript ，图片，字体，文件，媒体")])])]),e._v(" "),a("h3",{attrs:{id:"fmp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fmp"}},[e._v("#")]),e._v(" FMP")]),e._v(" "),a("p",[e._v('首次渲染有意义的内容的时间，"有意义"没有一个标准的定义，FMP的计算方法也很复杂。')]),e._v(" "),a("h3",{attrs:{id:"si-speed-index"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#si-speed-index"}},[e._v("#")]),e._v(" SI（Speed Index）")]),e._v(" "),a("p",[e._v("衡量页面加载期间内容以视觉方式显示的速度。")]),e._v(" "),a("p",[e._v("Lighthouse 首先捕获浏览器中页面加载的视频，并计算帧之间的视觉速度。通俗的讲，就是网页从有东西到完全显示内容的可见填充速度。")]),e._v(" "),a("p",[e._v("优化：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("减少主线程工作")])]),e._v(" "),a("li",[a("p",[e._v("减少 JavaScript 执行时间")])]),e._v(" "),a("li",[a("p",[e._v("确保文本在 webfont 加载期间保持可见")])])]),e._v(" "),a("h3",{attrs:{id:"ttfb-time-to-first-byte"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ttfb-time-to-first-byte"}},[e._v("#")]),e._v(" TTFB（Time to First Byte）")]),e._v(" "),a("p",[e._v("衡量对资源的请求和响应的第一个字节开始和到达之间时间的指标。")]),e._v(" "),a("p",[e._v("TTFB 是下列请求节点的时间损耗汇总：")]),e._v(" "),a("ul",[a("li",[e._v("Redirect time 重定向时延")]),e._v(" "),a("li",[e._v("Service worker 启动时延（如果适用）")]),e._v(" "),a("li",[e._v("DNS 查询时延")]),e._v(" "),a("li",[e._v("建立连接和 TLS 所消耗时延")]),e._v(" "),a("li",[e._v("请求，直到响应的第一个字节到达为止的时延")]),e._v(" "),a("li",[e._v("减少连接建立和后端服务的时延将有助于降低 TTFB")])]),e._v(" "),a("p",[e._v("TTFB 少于 0.8秒 。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new PerformanceObserver((entryList) => {\nconst [pageNav] = entryList.getEntriesByType('navigation');\n\nconsole.log(`TTFB: ${pageNav.responseStart}`);\n}).observe({\n  type: 'navigation',\n  buffered: true\n});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br"),a("span",{staticClass:"line-number"},[e._v("8")]),a("br")])]),a("p",[e._v("优化")]),e._v(" "),a("ul",[a("li",[e._v("托管服务商的基础设施能力不足，无法处理高流量负载")]),e._v(" "),a("li",[e._v("网络服务器的内存不足，可能导致 系统颠簸")]),e._v(" "),a("li",[e._v("未经优化的数据库")]),e._v(" "),a("li",[e._v("不良的数据库服务器配置")])]),e._v(" "),a("p",[e._v("其他优化高 TTFB 时延和相关感知延迟的机会包括：")]),e._v(" "),a("ul",[a("li",[e._v("避免多次重定向.")]),e._v(" "),a("li",[e._v("提前向跨域资源源建立连接 Preconnect 。")]),e._v(" "),a("li",[e._v("将源提交给HSTS预加载列表，以消除 HTTP-HTTPS 重定向延迟。")]),e._v(" "),a("li",[e._v("使用 HTTP/2 or HTTP/3。")]),e._v(" "),a("li",[e._v("考虑预测性预取，为没有指定减少数据使用偏好的用户提供快速页面导航。")]),e._v(" "),a("li",[e._v("在可能和适当的情况下，使用服务器端生成（SSG）来代替SSR的标记。")])]),e._v(" "),a("h3",{attrs:{id:"lcp-largest-contentful-paint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lcp-largest-contentful-paint"}},[e._v("#")]),e._v(" LCP（ Largest Contentful Paint）：")]),e._v(" "),a("p",[e._v("最大内容渲染时间（页面中最大布局变化后的第一次渲染）")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("new PerformanceObserver((entryList) => {\n  for (const entry of entryList.getEntries()) {\n    console.log('LCP candidate:', entry.startTime, entry);\n  }\n}).observe({type: 'largest-contentful-paint', buffered: true});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("LCP 指标值：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[e._v("* LCP <= 2.5s 合格\n\n* 2.5s < LCP <= 4s 需要优化\n\n* LCP > 4s 劣质\n")])])]),a("p",[e._v("导致 LCP 不佳的最常见原因是：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("缓慢的服务器响应速度，优化 TTFB")])]),e._v(" "),a("li",[a("p",[e._v("阻塞渲染的 JavaScript 和 CSS")]),e._v(" "),a("p",[e._v("浏览器在能够渲染任何内容之前，需要将 HTML 标记解析为 DOM 树。如果 HTML 解析器遇到任何外部样式表 link 或同步 JavaScript 标签 script，则会暂停解析。")]),e._v(" "),a("p",[e._v("脚本和样式表都是阻塞渲染的资源，这些资源会使 FCP 延迟，进而导致 LCP 延迟。延迟加载任何非关键的 JavaScript 和 CSS，从而提高网页主要内容的加载速度。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("减少 CSS 阻塞时间\n通过以下操作确保您的网站上只有最少量的必要 CSS 会阻塞渲染：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("削减 CSS（压缩）")])]),e._v(" "),a("li",[a("p",[e._v("延迟加载非关键 CSS")]),e._v(" "),a("p",[e._v("使用 Chrome 开发者工具中的代码覆盖率选项卡查找您网页上任何未使用的 CSS。")]),e._v(" "),a("p",[e._v("优化方式：")]),e._v(" "),a("p",[e._v("如果是在您网站的单独页面上使用，可以将所有未使用的 CSS 完全删除或移动到另一个样式表。\n对于任何初始渲染时不需要的 CSS，请使用 preload")])]),e._v(" "),a("li",[a("p",[e._v("内联关键 CSS")]),e._v(" "),a("p",[e._v("Critical、CriticalCSS 和 Penthouse 都是提取和内联首屏 CSS 的包")]),e._v(" "),a("p",[e._v("Critters 是一个 webpack 插件，能够内联关键 CSS 并对其余部分进行懒加载")])])])]),e._v(" "),a("li",[a("p",[e._v("减少 JavaScript 阻塞时间")]),e._v(" "),a("ul",[a("li",[e._v("削减和压缩 JavaScript 文件")]),e._v(" "),a("li",[e._v("延迟加载未使用的 JavaScript")]),e._v(" "),a("li",[e._v("最大限度减少未使用的 polyfill")])])])])]),e._v(" "),a("li",[a("p",[e._v("缓慢的资源加载速度")]),e._v(" "),a("p",[e._v("影响 LCP 的元素类型为：")]),e._v(" "),a("ul",[a("li",[e._v("img元素")]),e._v(" "),a("li",[e._v("内嵌在svg元素内的image元素")]),e._v(" "),a("li",[e._v("video元素（使用封面图像测量 LCP）")]),e._v(" "),a("li",[e._v("通过url()函数（而非使用 CSS 渐变）加载的带有背景图像的元素")]),e._v(" "),a("li",[e._v("包含文本节点或其他行内级文本元素的块级元素")])]),e._v(" "),a("p",[e._v("如果在首屏渲染，加载这些元素所需的时间将对 LCP 产生直接影响。有几种方法可以确保尽快加载这些文件：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("优化和压缩图像")]),e._v(" "),a("ul",[a("li",[e._v("考虑不使用图像。如果图像与内容无关，请将其删除。")]),e._v(" "),a("li",[e._v("压缩图像（例如使用 Imagemin）")]),e._v(" "),a("li",[e._v("将图像转换为更新的格式（JPEG 2000、JPEG XR 或 WebP）")]),e._v(" "),a("li",[e._v("使用响应式图像")]),e._v(" "),a("li",[e._v("考虑使用图像 CDN")])])]),e._v(" "),a("li",[a("p",[e._v("预加载重要资源")]),e._v(" "),a("p",[e._v("有时，在某个 CSS 或 JavaScript 文件中声明或使用的重要资源可能会比您所期望的要晚一点被获取，例如深藏在应用程序众多 CSS 文件中的某个字体。")]),e._v(" "),a("p",[e._v("如果您知道某个特定资源应该被优先获取，请使用 "),a("strong",[e._v("link preload")]),e._v(" 来更加及时地获取该资源。 多种类型的资源都可以进行预加载，但您应该首先侧重于预加载关键资产，例如字体、首屏图像或视频，以及关键路径 CSS 或 JavaScript。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<link rel="preload" as="script" href="script.js" />\n<link rel="preload" as="style" href="style.css" />\n<link rel="preload" as="image" href="img.png" />\n<link rel="preload" as="video" href="vid.webm" type="video/webm" />\n<link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin />\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("从 Chrome 73 开始，预加载可以与响应式图像一起使用，将两种模式相结合能够实现更快速的图像加载。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('<link\n  rel="preload"\n  as="image"\n  href="wolf.jpg"\n  imagesrcset="wolf_400px.jpg 400w, wolf_800px.jpg 800w, wolf_1600px.jpg 1600w"\n  imagesizes="50vw"\n/>\n')])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])])]),e._v(" "),a("li",[a("p",[e._v("压缩文本文件")]),e._v(" "),a("p",[e._v("压缩诸如 Gzip 和 Brotli 之类的算法可以显著缩减在服务器和浏览器之间传输的文本文件（HTML、CSS、JavaScript）大小。所有浏览器都有效支持 Gzip，而 Brotli 几乎可以在所有较新的浏览器中使用，并能提供更好的压缩结果。")]),e._v(" "),a("p",[e._v("压缩您的资源将最大限度地减少这些资源的交付大小、缩短加载时间，从而改善 LCP。")]),e._v(" "),a("p",[e._v("首先，检查您的服务器是否已经自动压缩文件。大多数托管平台、CDN 和反向代理服务器在默认情况下都会对资产进行压缩编码，或者使您能够轻松配置资产。")]),e._v(" "),a("p",[e._v("如果您需要对服务器进行修改来使其压缩文件，请考虑使用 "),a("strong",[e._v("Brotli")]),e._v("，而不是 gzip，因为 Brotli 可以提供更好的压缩率。")]),e._v(" "),a("p",[e._v("选择您要使用的压缩算法后，请在构建过程中提前压缩资产，而不是在浏览器请求时实时压缩资产。这样能够最大限度地减少服务器开销并防止在发出请求时出现延迟，尤其是在使用高压缩比的情况下。")])]),e._v(" "),a("li",[a("p",[e._v("基于网络连接交付不同资产（自适应服务）")]),e._v(" "),a("p",[e._v("当加载构成页面主要内容的资源时，根据用户的设备或网络条件按需获取不同的资源会是一个有效做法。您可以使用网络状况 API、设备内存 API 和硬件并发 API 来实现这一做法。")]),e._v(" "),a("p",[e._v("如果您有对初始渲染十分关键的大型资产，那么您可以根据用户的连接或设备采用同一资源的不同变体。例如，对于任何低于 4G 的连接速度，您可以显示图像，而不是视频：")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if (navigator.connection && navigator.connection.effectiveType) {\n  if (navigator.connection.effectiveType === '4g') {\n    // 加载视频\n  } else {\n    // 加载图像\n  }\n}\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("p",[e._v("您可以使用的一系列实用属性：")]),e._v(" "),a("ul",[a("li",[e._v("navigator.connection.effectiveType：有效连接类型")]),e._v(" "),a("li",[e._v("navigator.connection.saveData：启用/禁用数据保护程序")]),e._v(" "),a("li",[e._v("navigator.hardwareConcurrency：CPU 核心数")]),e._v(" "),a("li",[e._v("navigator.deviceMemory：设备内存")])])]),e._v(" "),a("li",[a("p",[e._v("使用 Service Worker 缓存资产")]),e._v(" "),a("p",[e._v("Service Worker 可用于缓存任何静态资源，并在收到重复请求时将资源直接提供给浏览器，而无需通过网络。")]),e._v(" "),a("p",[e._v("使用 Service Worker 预缓存关键资源可以显著减少资源加载时间，特别是对于使用较弱连接重新加载网页（甚至离线访问）的用户。与自己编写自定义 Service Worker 来更新预缓存资产相比，诸如 Workbox 这样的库可以使整个过程更加容易。")])])])]),e._v(" "),a("li",[a("p",[e._v("客户端渲染")]),e._v(" "),a("p",[e._v("在搭建客户端渲染的网站时，请考虑以下优化：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("最小化关键 JavaScript")])]),e._v(" "),a("li",[a("p",[e._v("使用服务端渲染")])]),e._v(" "),a("li",[a("p",[e._v("使用预渲染")]),e._v(" "),a("p",[e._v("预渲染是一种独立的技巧，该技巧比服务端渲染简单，并且还提供了一种改进应用程序 LCP 的方法。无头浏览器是一种没有用户界面的浏览器，我们会用无头浏览器在搭建期间生成每个路由的静态 HTML 文件。然后可以将这些文件与应用程序所需的 JavaScript 包一起进行运送。")]),e._v(" "),a("p",[e._v("在使用预渲染后，TTI 仍然会受到负面影响，但服务器响应时间不会像服务端渲染解决方案（仅在接到请求后才对各个页面进行动态渲染）中那样受到很大影响。")])])])])]),e._v(" "),a("h2",{attrs:{id:"可交互时间指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可交互时间指标"}},[e._v("#")]),e._v(" 可交互时间指标")]),e._v(" "),a("h3",{attrs:{id:"首次可交互时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#首次可交互时间"}},[e._v("#")]),e._v(" 首次可交互时间")]),e._v(" "),a("p",[e._v("首次可交互，即DOM加载并解析完成后，界面上的元素可以交互（如输入框可以输入、按钮可以点击、超长元素可以滚动）。其时间用performance.timing.domInteractive计算")]),e._v(" "),a("p",[e._v('performance.timing.domInteractive：当前网页DOM结构结束解析、开始加载内嵌资源的时间，document.readyState 变成interactive，并将抛出"readyStateChange"事件（注意只是DOM树解析完成，这时候并没有开始加载网页内的资源）')]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("  const timeToInteractive = performance.timing.domInteractive - performance.timing.fetchStart, //首次可交互时间\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("h3",{attrs:{id:"tti-time-to-interactive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tti-time-to-interactive"}},[e._v("#")]),e._v(" TTI（Time to Interactive）")]),e._v(" "),a("p",[e._v("用于标记应用已进行视觉渲染并能可靠响应用户输入的时间点")]),e._v(" "),a("p",[e._v("完全可交互状态的页面")]),e._v(" "),a("ul",[a("li",[e._v("页面已经显示有用内容。")]),e._v(" "),a("li",[e._v("页面上的可见元素关联的事件响应函数已经完成注册。")]),e._v(" "),a("li",[e._v("事件响应函数可以在事件发生后的 50ms 内开始执行（主线程无 Long Task）。")])]),e._v(" "),a("p",[e._v("计算方法描述如下：")]),e._v(" "),a("p",[e._v("从 FCP 时间开始，向前搜索一个不小于 5s 的静默窗口期。（静默窗口期定义：窗口所对应的时间内没有 Long Task，且进行中的网络请求数不超过 2 个）\n找到静默窗口期后，从静默窗口期向后搜索到最近的一个 Long Task，Long Task 的结束时间即为 TTI。\n如果一直找到 FCP 时刻仍然没有找到 Long Task，以 FCP 时间作为 TTI。")]),e._v(" "),a("h3",{attrs:{id:"fid-first-input-delay"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fid-first-input-delay"}},[e._v("#")]),e._v(" FID（First Input Delay）")]),e._v(" "),a("p",[e._v("用于度量用户第一次与页面交互的延迟时间，是用户第一次与页面交互到浏览器真正能够开始处理事件处理程序以响应该交互的时间。")]),e._v(" "),a("p",[e._v("100 毫秒或以内，FID 只关注不连续操作对应的输入事件，如点击、轻触和按键。")]),e._v(" "),a("p",[e._v("优化：")]),e._v(" "),a("ul",[a("li",[e._v("分割长任务")]),e._v(" "),a("li",[e._v("优化您的页面，做好交互准备\n"),a("ul",[a("li",[e._v("第一方脚本执行会延迟交互准备")]),e._v(" "),a("li",[e._v("数据获取会影响交互准备的许多方面")]),e._v(" "),a("li",[e._v("第三方脚本执行也会加剧交互延迟")])])]),e._v(" "),a("li",[e._v("使用 Web Worker")]),e._v(" "),a("li",[e._v("减少 JavaScript 执行时间")])]),e._v(" "),a("p",[e._v("回调的触发时机是用户首次与页面发生交互并得到浏览器响应（点击链接、输入文字等）。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("const observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    console.log('fid', entry.processingStart - entry.startTime);\n  }\n});\n\nobserver.observe({type: 'first-input', buffer: true});\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br"),a("span",{staticClass:"line-number"},[e._v("6")]),a("br"),a("span",{staticClass:"line-number"},[e._v("7")]),a("br")])]),a("h3",{attrs:{id:"tbt-total-blocking-time"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tbt-total-blocking-time"}},[e._v("#")]),e._v(" TBT （ Total Blocking Time）")]),e._v(" "),a("p",[e._v("总阻塞时间，是页面被阻塞响应用户交互的总时间。 TBT = LCP （首次最大内容绘制）和可交互时间之间所有长时间任务的阻塞部分之和。是测量页面加载响应的重要指标。")]),e._v(" "),a("p",[e._v("超过 50 毫秒的任务即为长任务。 超出 50 毫秒的时间量为阻塞部分。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("优化")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("减少不必要的 JavaScript 加载、解析或执行。减少 JavaScript 负载、删除未使用的代码或有效加载第三方 JavaScript 可以提高 TBT 分数。")])]),e._v(" "),a("li",[a("p",[e._v("减少低效的 JavaScript 语句。例如： document.querySelectorAll('a') 会返回所有符合的节点")])])])])]),e._v(" "),a("h2",{attrs:{id:"稳定性指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#稳定性指标"}},[e._v("#")]),e._v(" 稳定性指标")]),e._v(" "),a("h3",{attrs:{id:"cls-cumulative-layout-shift"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cls-cumulative-layout-shift"}},[e._v("#")]),e._v(" CLS（Cumulative Layout Shift）")]),e._v(" "),a("p",[e._v("CLS是对在页面的整个生命周期中发生的每一次意外布局变化的最大布局变化得分的度量，布局变化得分越小证明你的页面越稳定。")]),e._v(" "),a("p",[e._v("计算公式： 布局偏移分数 = 影响分数 x 距离分数")]),e._v(" "),a("p",[e._v("影响分数： 前一帧和当前帧的所有不稳定元素的课件区域集合（占总可视区域的部分）就是当前帧的影响分数。")]),e._v(" "),a("p",[e._v("距离分数： 指的是任何不稳定元素在一帧中位移的最大距离（水平或垂直）除以可视区域的最大尺寸维度（宽度或高度，以较大者为准）。")]),e._v(" "),a("p",[e._v("CLS 分数小于 0.1 。")]),e._v(" "),a("h4",{attrs:{id:"如何改善cls"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何改善cls"}},[e._v("#")]),e._v(" 如何改善CLS？")]),e._v(" "),a("p",[e._v("对大部分网站而言，可以参考以下:")]),e._v(" "),a("ul",[a("li",[e._v("对图片和视频元素总是设定好尺寸，否则保留所需的空间。这样可以保证浏览器给这些元素分配足够的空间，在加载之后，不会产生布局偏移。如果浏览器支持，可以开启 unsized-media feature policy 的策略。")]),e._v(" "),a("li",[e._v("永远不要把内容插入到已有元素的上方，除非为了响应用户交互。")]),e._v(" "),a("li",[e._v("如果需要用到动画，优先使用不会产生布局偏移的CSS属性。")])]),e._v(" "),a("h2",{attrs:{id:"流畅性指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流畅性指标"}},[e._v("#")]),e._v(" 流畅性指标")]),e._v(" "),a("h3",{attrs:{id:"fps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fps"}},[e._v("#")]),e._v(" FPS")]),e._v(" "),a("p",[e._v("Chrome DevTool 中有一栏 Rendering 中包含 FPS 指标，但目前浏览器标准中暂时没有提供相应 API ，只能手动实现。这里需要借助 requestAnimationFrame 方法模拟实现，浏览器会在下一次重绘之前执行 rAF 的回调，因此可以通过计算每秒内 rAF 的执行次数来计算当前页面的 FPS。")]),e._v(" "),a("p",[e._v("FPS过低会让用户感觉卡顿，因此这个计算可以用来监控页面卡顿情况。")]),e._v(" "),a("h2",{attrs:{id:"core-web-vitals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#core-web-vitals"}},[e._v("#")]),e._v(" Core Web Vitals")]),e._v(" "),a("p",[e._v("Core Web Vitals是谷歌提出的，衡量用户体验的新指标，指标将被纳入谷歌搜索引擎的网页排名。")]),e._v(" "),a("p",[e._v("Core Web Vitals是用户体验和SEO的重要指标。")]),e._v(" "),a("p",[e._v("关键的指标包括")]),e._v(" "),a("ul",[a("li",[e._v("LCP，用来衡量页面加载性能，为了提供良好的用户体验，LCP应该在页面首次开始加载后的2.5秒内发生")]),e._v(" "),a("li",[e._v("FID，衡量交互性能，为了提供良好的用户体验，页面的FID应该小于100毫秒。")]),e._v(" "),a("li",[e._v("CLS，测量视觉稳定性。为了提供良好的用户体验，页面应该保持CLS小于0.1。")])]),e._v(" "),a("p",[e._v("Chrome提供了web-vitals库获取3个关键指标的数值。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("import { getLCP, getFID, getCLS } from 'web-vitals';\n\ngetCLS(console.log);\ngetFID(console.log);\ngetLCP(console.log);\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("h2",{attrs:{id:"工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工具"}},[e._v("#")]),e._v(" 工具")]),e._v(" "),a("h3",{attrs:{id:"lighthouse"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lighthouse"}},[e._v("#")]),e._v(" lighthouse")]),e._v(" "),a("h3",{attrs:{id:"chrome-devtool"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chrome-devtool"}},[e._v("#")]),e._v(" chrome devtool")]),e._v(" "),a("p",[e._v("Chrome 开发者工具中性能面板")]),e._v(" "),a("h3",{attrs:{id:"chrome-用户体验报告"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chrome-用户体验报告"}},[e._v("#")]),e._v(" chrome 用户体验报告")])])}),[],!1,null,null,null);t.default=v.exports}}]);