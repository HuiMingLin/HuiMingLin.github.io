(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{437:function(t,v,a){"use strict";a.r(v);var _=a(25),s=Object(_.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"概述"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),a("p",[t._v("微前端是一种将不同的前端应用组合到一起的架构模式。这些应用可以独立开发、独立部署、独立运行，然后在一个主应用中进行集成。这种模式的主要目标是解决大型、长期演进的前端项目的复杂性问题。")]),t._v(" "),a("p",[t._v("主要优点：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("解耦： 微前端架构可以将大型项目分解为多个可以独立开发、测试和部署的小型应用。这种解耦可以提高开发效率，减少团队间的协调成本。")])]),t._v(" "),a("li",[a("p",[t._v("技术栈无关： 不同的微前端应用可以使用不同的技术栈，这为使用新技术、升级旧技术提供了可能。")])]),t._v(" "),a("li",[a("p",[t._v("并行开发： 因为微前端应用是独立的，所以多个团队可以并行开发不同的应用，无需担心相互影响。")])]),t._v(" "),a("li",[a("p",[t._v("独立部署： 每个微前端应用可以独立部署，这意味着可以更快地推出新功能，同时降低了部署失败的风险。")])])]),t._v(" "),a("p",[t._v("主要挑战：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("性能问题： 如果不同的微前端应用使用了不同的库或框架，可能会导致加载和运行的性能问题。")])]),t._v(" "),a("li",[a("p",[t._v("一致性： 保持不同的微前端应用在用户体验、设计和行为上的一致性可能会比较困难。")])]),t._v(" "),a("li",[a("p",[t._v("状态共享： 在微前端应用之间共享状态可能会比较复杂，需要使用特殊的工具或模式。")])]),t._v(" "),a("li",[a("p",[t._v("复杂性： 尽管微前端可以解决大型项目的复杂性问题，但是它自身也带来了一些复杂性，比如需要管理和协调多个独立的应用。")])]),t._v(" "),a("li",[a("p",[t._v("安全性： 微前端架构可能会增加跨域等安全问题。")])])]),t._v(" "),a("p",[t._v("难点：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("预加载")]),t._v(" "),a("p",[t._v("空闲时加载子应用资源，用户行为数据支持")])]),t._v(" "),a("li",[a("p",[t._v("公共依赖加载")]),t._v(" "),a("p",[t._v("大部分子应用都用到的资源如何处理")])]),t._v(" "),a("li",[a("p",[t._v("按需加载")]),t._v(" "),a("p",[t._v("切换页面时才加载相应的HTML、CSS和JS")])]),t._v(" "),a("li",[a("p",[t._v("Config Entry")]),t._v(" "),a("p",[t._v("配置每个子应用的 JS 和 CSS 包括内联的那些")])]),t._v(" "),a("li",[a("p",[t._v("HTML Entry")]),t._v(" "),a("p",[t._v("Config Entry 的进阶版，简化开发者使用，但把解析消耗留给用户")])]),t._v(" "),a("li",[a("p",[t._v("CSS 隔离")]),t._v(" "),a("p",[t._v("子应用之间样式互不影响，切换时装载和卸载")])]),t._v(" "),a("li",[a("p",[t._v("JS 沙箱")]),t._v(" "),a("p",[t._v("子应用之后互不影响，包括全局变量、事件等处理")])]),t._v(" "),a("li",[a("p",[t._v("子应用并行")]),t._v(" "),a("p",[t._v("多个微前端如何同时存在进阶用法")])]),t._v(" "),a("li",[a("p",[t._v("子应用嵌套")]),t._v(" "),a("p",[t._v("微前端如何嵌套前端进阶用法")])]),t._v(" "),a("li",[a("p",[t._v("父子应用通讯")]),t._v(" "),a("p",[t._v("子应用如何调用父应用方法，父应用如何下发状态")])])]),t._v(" "),a("h2",{attrs:{id:"qiankun"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#qiankun"}},[t._v("#")]),t._v(" qiankun")]),t._v(" "),a("p",[t._v("qiankun 是一个基于 single-spa 的微前端实现框架。")]),t._v(" "),a("p",[t._v("优点")]),t._v(" "),a("ul",[a("li",[t._v("降低了应用改造的成本，通过html entry的方式引入子应用；")]),t._v(" "),a("li",[t._v("提供了完备的沙箱方案，包括js沙箱和css沙箱；")]),t._v(" "),a("li",[t._v("支持静态资源预加载能力。")])]),t._v(" "),a("p",[t._v("缺点")]),t._v(" "),a("ul",[a("li",[t._v("适配成本较高，包括工程化、生命周期、静态资源路径、路由等方面的适配；")]),t._v(" "),a("li",[t._v("css沙箱的严格隔离可能引发问题，js沙箱在某些场景下执行性能下降；")]),t._v(" "),a("li",[t._v("无法同时激活多个子应用，不支持子应用保活；")]),t._v(" "),a("li",[t._v("不支持vite等esmodule脚本运行。")])]),t._v(" "),a("h3",{attrs:{id:"工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工作原理"}},[t._v("#")]),t._v(" 工作原理")]),t._v(" "),a("p",[t._v("应用加载：qiankun 通过动态创建 script 标签的方式加载子应用的入口文件。加载完成后，会执行子应用暴露出的生命周期函数。")]),t._v(" "),a("p",[t._v("生命周期管理：qiankun 要求每个子应用都需要暴露出 bootstrap、mount 和 unmount 三个生命周期函数。bootstrap 函数在应用加载时被调用，mount 函数在应用启动时被调用，unmount 函数在应用卸载时被调用。")]),t._v(" "),a("p",[t._v("沙箱隔离：qiankun 通过 Proxy 对象创建了一个 JavaScript 沙箱，用于隔离子应用的全局变量，防止子应用之间的全局变量污染。但是如果我们在子应用中添加了一个全局的点击事件，我们可以在子应用的 unmount 生命周期函数中移除这个事件。")]),t._v(" "),a("p",[t._v("样式隔离：qiankun 通过动态添加和移除样式标签的方式实现了样式隔离。当子应用启动时，会动态添加子应用的样式标签，当子应用卸载时，会移除子应用的样式标签。")]),t._v(" "),a("p",[t._v("通信机制：qiankun 提供了一个全局的通信机制，允许子应用之间进行通信。")]),t._v(" "),a("h3",{attrs:{id:"加载静态资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加载静态资源"}},[t._v("#")]),t._v(" 加载静态资源")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("使用公共路径\n在子应用的静态资源路径前添加公共路径前缀。例如，如果子应用的静态资源存放在 http://localhost:8080/static/，那么可以在所有的静态资源路径前添加这个前缀。")])]),t._v(" "),a("li",[a("p",[t._v("劫持标签插入函数")]),t._v(" "),a("p",[t._v("这个方案分为两步：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("对于 HTML 中已有的 img/audio/video 等标签，qiankun 支持重写 getTemplate 函数，可以将入口文件 index.html 中的静态资源路径替换掉。")])]),t._v(" "),a("li",[a("p",[t._v("对于动态插入的 img/audio/video 等标签，劫持 appendChild、innerHTML、insertBefore 等事件，将资源的相对路径替换成绝对路径。")]),t._v(" "),a("p",[t._v("例如，我们可以传递一个 getTemplate 函数，将图片的相对路径转为绝对路径，它会在处理模板时使用：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("start({\n  getTemplate(tpl,...rest) {\n    // 为了直接看到效果，所以写死了，实际中需要用正则匹配\n    return tpl.replace('<img src=\"./img/jQuery1.png\">', '<img src=\"http://localhost:3333/img/jQuery1.png\">');\n  }\n});\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])]),a("p",[t._v("对于动态插入的标签，劫持其插入 DOM 的函数，注入前缀。")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("beforeMount: app => {\n  if(app.name === 'purehtml'){\n      // jQuery 的 html 方法是一个挺复杂的函数，这里只是为了看效果，简写了\n      $.prototype.html = function(value){\n          const str = value.replace('<img src=\"/img/jQuery2.png\">', '<img src=\"http://localhost:3333/img/jQuery2.png\">')\n          this[0].innerHTML = str;\n      }\n  }\n}\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br")])])])])]),t._v(" "),a("li",[a("p",[t._v("项目加上 webpack 打包")])])]),t._v(" "),a("h3",{attrs:{id:"资源加载机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#资源加载机制"}},[t._v("#")]),t._v(" 资源加载机制")]),t._v(" "),a("p",[t._v("qiankun import-html-entry 是qiankun 框架中用于加载子应用的 HTML 入口文件的工具函数。它提供了一种方便的方式来动态加载和解析子应用的 HTML 入口文件，并返回一个可以加载子应用的 JavaScript 模块。")]),t._v(" "),a("p",[t._v("具体而言，import-html-entry 实现了以下功能：")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("加载 HTML 入口文件：import-html-entry 会通过创建一个 "),a("link"),t._v(" 标签来加载子应用的 HTML 入口文件。这样可以确保子应用的资源得到正确加载，并在加载完成后进行处理。")])]),t._v(" "),a("li",[a("p",[t._v("解析 HTML 入口文件：一旦 HTML 入口文件加载完成，import-html-entry 将解析该文件的内容，提取出子应用的 JavaScript 和 CSS 资源的 URL。")])]),t._v(" "),a("li",[a("p",[t._v("动态加载 JavaScript 和 CSS 资源：import-html-entry 使用动态创建 script 和 link 标签的方式，按照正确的顺序加载子应用的 JavaScript 和 CSS 资源。")])]),t._v(" "),a("li",[a("p",[t._v("创建沙箱环境：在加载子应用的 JavaScript 资源时，import-html-entry 会创建一个沙箱环境（sandbox），用于隔离子应用的全局变量和运行环境，防止子应用之间的冲突和污染。")])]),t._v(" "),a("li",[a("p",[t._v("返回子应用的入口模块：最后，import-html-entry 返回一个可以加载子应用的 JavaScript 模块。这个模块通常是一个包含子应用初始化代码的函数，可以在主应用中调用以加载和启动子应用。")])])]),t._v(" "),a("p",[t._v("通过使用 qiankun import-html-entry，开发者可以方便地将子应用的 HTML 入口文件作为模块加载，并获得一个可以加载和启动子应用的函数，简化了子应用的加载和集成过程。")]),t._v(" "),a("h3",{attrs:{id:"start-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#start-函数"}},[t._v("#")]),t._v(" start 函数")]),t._v(" "),a("p",[t._v("start 函数接收一个可选的配置对象作为参数，这个对象可以包含以下属性：")]),t._v(" "),a("p",[t._v("prefetch：预加载模式，可选值有 true、false、'all'、'popstate'。默认值为 true，即在主应用 start 之后即刻开始预加载所有子应用的静态资源。如果设置为 'all'，则主应用 start 之后会预加载所有子应用静态资源，无论子应用是否激活。如果设置为 'popstate'，则只有在路由切换的时候才会去预加载对应子应用的静态资源。")]),t._v(" "),a("p",[t._v("sandbox：沙箱模式，可选值有 true、false、{ strictStyleIsolation: true }。默认值为 true，即为每个子应用创建一个新的沙箱环境。如果设置为 false，则子应用运行在当前环境下，没有任何的隔离。如果设置为 { strictStyleIsolation: true }，则会启用严格的样式隔离模式，即子应用的样式会被完全隔离，不会影响到其他子应用和主应用。")]),t._v(" "),a("p",[t._v("singular：是否为单例模式，可选值有 true、false。默认值为 true，即一次只能有一个子应用处于激活状态。如果设置为 false，则可以同时激活多个子应用。")]),t._v(" "),a("p",[t._v("fetch：自定义的 fetch 方法，用于加载子应用的静态资源。")]),t._v(" "),a("p",[t._v("如果只有一个子项目，要想启用预加载，可以这样使用 start 函数：")]),t._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("start({ prefetch: 'all' });\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("这样，主应用 start 之后会预加载子应用的所有静态资源，无论子应用是否激活。")]),t._v(" "),a("h2",{attrs:{id:"micro-app-方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#micro-app-方案"}},[t._v("#")]),t._v(" micro-app 方案")]),t._v(" "),a("p",[t._v("优点")]),t._v(" "),a("ul",[a("li",[t._v("使用 webcomponent 加载子应用，更优雅；")]),t._v(" "),a("li",[t._v("复用经过大量项目验证过的 qiankun 沙箱机制，提高了框架的可靠性；")]),t._v(" "),a("li",[t._v("支持子应用保活；")]),t._v(" "),a("li",[t._v("降低了子应用改造的成本，提供了静态资源预加载能力。")])]),t._v(" "),a("p",[t._v("缺点")]),t._v(" "),a("ul",[a("li",[t._v("接入成本虽然降低，但路由依然存在依赖；")]),t._v(" "),a("li",[t._v("多应用激活后无法保持各子应用的路由状态，刷新后全部丢失；")]),t._v(" "),a("li",[t._v("css 沙箱无法完全隔离，js 沙箱做全局变量查找缓存，性能有所优化；")]),t._v(" "),a("li",[t._v("支持 vite 运行，但必须使用 plugin 改造子应用，且 js 代码没办法做沙箱隔离；")]),t._v(" "),a("li",[t._v("对于不支持 webcomponent 的浏览器没有做降级处理。")])]),t._v(" "),a("h2",{attrs:{id:"emp-方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#emp-方案"}},[t._v("#")]),t._v(" EMP 方案")]),t._v(" "),a("p",[t._v("优点")]),t._v(" "),a("ul",[a("li",[t._v("webpack 联邦编译可以保证所有子应用依赖解耦；")]),t._v(" "),a("li",[t._v("支持应用间去中心化的调用、共享模块；")]),t._v(" "),a("li",[t._v("支持模块远程 ts 支持。")])]),t._v(" "),a("p",[t._v("缺点")]),t._v(" "),a("ul",[a("li",[t._v("对 webpack 强依赖，对于老旧项目不友好；")]),t._v(" "),a("li",[t._v("没有有效的 css 沙箱和 js 沙箱，需要靠用户自觉；")]),t._v(" "),a("li",[t._v("子应用保活、多应用激活无法实现；")]),t._v(" "),a("li",[t._v("主、子应用的路由可能发生冲突。")])]),t._v(" "),a("h2",{attrs:{id:"无界方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#无界方案"}},[t._v("#")]),t._v(" 无界方案")]),t._v(" "),a("p",[t._v("优点")]),t._v(" "),a("p",[t._v("基于 webcomponent 容器和 iframe 沙箱，充分解决了适配成本、样式隔离、运行性能、页面白屏、子应用通信、子应用保活、多应用激活、vite框架支持、应用共享等问题。\n缺点")]),t._v(" "),a("p",[t._v("在继承了iframe优点的同时，缺点依旧还是存在，因为它使得主应用和子应用之间的通信变得困难。此外，iframe 还有一些其他的问题，比如性能问题、SEO 问题等。")]),t._v(" "),a("h2",{attrs:{id:"微服务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微服务"}},[t._v("#")]),t._v(" 微服务")]),t._v(" "),a("h3",{attrs:{id:"hapi"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hapi"}},[t._v("#")]),t._v(" Hapi")]),t._v(" "),a("h3",{attrs:{id:"restfy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#restfy"}},[t._v("#")]),t._v(" Restfy")])])}),[],!1,null,null,null);v.default=s.exports}}]);