(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{216:function(t,n,e){"use strict";e.r(n);var r=e(0),a=Object(r.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"es5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es5"}},[t._v("#")]),t._v(" ES5")]),t._v(" "),e("h2",{attrs:{id:"手写-call、apply-及-bind-函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手写-call、apply-及-bind-函数"}},[t._v("#")]),t._v(" 手写 call、apply 及 bind 函数")]),t._v(" "),e("p",[t._v("首先从以下几点来考虑如何实现这几个函数")]),t._v(" "),e("ul",[e("li",[t._v("不传入第一个参数，那么上下文默认为 "),e("code",[t._v("window")])]),t._v(" "),e("li",[t._v("改变了 "),e("code",[t._v("this")]),t._v(" 指向，让新的对象可以执行该函数，并能接受参数")])]),t._v(" "),e("p",[t._v("那么我们先来实现 call")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('  Function.prototype.myCall = function(context, ...args) {\n    if (typeof context !== "function") {\n      throw new typeError("Error");\n    }\n\n    context = context || window;\n    context.fn = this;\n\n    const result = context.fn(...args);\n    delete context.fn;\n    return result;\n  };\n')])])]),e("p",[t._v("以下是对实现的分析：")]),t._v(" "),e("p",[t._v("首先 "),e("code",[t._v("context")]),t._v(" 为可选参数，如果不传的话默认上下文为 window\n接下来给 "),e("code",[t._v("context")]),t._v(" 创建一个 fn 属性，并将值设置为需要调用的函数\n因为 "),e("code",[t._v("call")]),t._v(" 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来\n然后调用函数并将对象上的函数删除")]),t._v(" "),e("p",[t._v("实现 apply")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('  Function.prototype.myApply = function(context, args) {\n    if (typeof context !== "function") {\n      throw new typeError("Error");\n    }\n\n    context = context || window;\n    context.fn = this;\n    let result;\n\n    if (args) {\n      result = context.fn(...args);\n    } else {\n      result = context.fn();\n    }\n    delete context.fn;\n    return result;\n  };\n')])])]),e("p",[t._v("bind 的实现对比其他两个函数略微地复杂了一点，因为 bind 需要返回一个函数，\n需要判断一些边界问题，以下是 bind 的实现")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('  Function.prototype.myBind = function(context, ...args) {\n    if (typeof this !== "function") {\n      throw new TypeError("Error");\n    }\n    const _that = this;\n    return function F() {\n      if (this instanceof F) {\n        return new _that(...args, ...arguments);\n      }\n\n      return _that.apply(context, args.concat(...arguments));\n    };\n  };\n')])])]),e("p",[t._v("以下是对实现的分析：")]),t._v(" "),e("ul",[e("li",[t._v("前几步和之前的实现差不多，就不赘述了")]),t._v(" "),e("li",[t._v("bind 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 new 的方式，我们先来说直接调用的方式")]),t._v(" "),e("li",[t._v("对于直接调用来说，这里选择了 apply 的方式实现，但是对于参数需要注意以下情况：因为 bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 args.concat(...arguments)")]),t._v(" "),e("li",[t._v("最后来说通过 new 的方式，在之前的章节中我们学习过如何判断 this，对于 new 的情况来说，不会被任何方式改变 this，所以对于这种情况我们需要忽略传入的 this")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  function myInstance(left, right) {\n    const prototype = right.prototype;\n    left = left.__proto__;\n\n    while (true) {\n      if (left === null || left === undefined) {\n        return false;\n      }\n      if (prototype === left) {\n        return true;\n      }\n      left = left.__proto__;\n    }\n  }\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);