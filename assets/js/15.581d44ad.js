(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{221:function(n,e,t){"use strict";t.r(e);var a=t(0),r=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"创建型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建型模式"}},[n._v("#")]),n._v(" 创建型模式")]),n._v(" "),t("p",[n._v("创建型模式的目的就是封装创建对象的变化")]),n._v(" "),t("p",[n._v("这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。\n这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。")]),n._v(" "),t("ul",[t("li",[n._v("工厂模式（Factory Pattern）")]),n._v(" "),t("li",[n._v("抽象工厂模式（Abstract Factory Pattern）")]),n._v(" "),t("li",[n._v("单例模式（Singleton Pattern）")]),n._v(" "),t("li",[n._v("建造者模式（Builder Pattern）")]),n._v(" "),t("li",[n._v("原型模式（Prototype Pattern）")])]),n._v(" "),t("h2",{attrs:{id:"单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单例模式"}},[n._v("#")]),n._v(" ** 单例模式 **")]),n._v(" "),t("p",[n._v("** 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 **")]),n._v(" "),t("h3",{attrs:{id:"_1、实现单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、实现单例模式"}},[n._v("#")]),n._v(" 1、实现单例模式")]),n._v(" "),t("p",[n._v("单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全局缓存、浏 览器中的 window 对象等。\n在 JavaScript 开发中，单例模式的用途同样非常广泛。\n试想一下，当我们单击登录按钮的时候，页面中会出现一个登录浮窗，\n而这个登录浮窗是唯一的，无论单击多少次登录按钮，这个浮窗都只会被创建一次，那么这个登录浮窗就适合用单例模式来创建。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('  var CreateDiv = (function() {\n    var instance;\n    var CreateDiv = function(html) {\n      if (instance) {\n        return instance;\n      }\n      this.html = html;\n      this.init();\n      return (instance = this);\n    };\n\n    CreateDiv.prototype.init = function() {\n      var div = document.createElement("div");\n      div.innerHTML = this.html;\n      document.body.appendChild(div);\n    };\n\n    return CreateDiv;\n  })();\n\n  var a = new CreateDiv("sven1");\n  var b = new CreateDiv("sven2");\n  alert(a === b); // true\n')])])]),t("p",[n._v("为了把 instance 封装起来，我们使用了自执行的匿名函数和闭包，并且让这个匿名函数返回\n真正的 Singleton 构造方法，这增加了一些程序的复杂度，阅读起来也不是很舒服。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var CreateDiv = function( html ){ \n  if ( instance ){\n    return instance; \n  }\n  this.html = html;\n  this.init();\n  return instance = this;\n};\n")])])]),t("p",[n._v("在这段代码中，CreateDiv 的构造函数实际上负责了两件事情。\n第一是创建对象和执行初始化 init 方法，第二是保证只有一个对象。\n不符合 “单一职责原则” 的概念， 可以明确的是，这是一种不好的做法，至少这个构造函数看起来很奇怪。")]),n._v(" "),t("p",[n._v("假设我们某天需要利用这个类，在页面中创建千千万万的 div，即要让这个类从单例类变成 一个普通的可产生多个实例的类，\n那我们必须得改写 CreateDiv 构造函数，把控制创建唯一对象的那一段去掉，这种修改会给我们带来不必要的烦恼。")]),n._v(" "),t("h3",{attrs:{id:"_2、用代理实现单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、用代理实现单例模式"}},[n._v("#")]),n._v(" 2、用代理实现单例模式")]),n._v(" "),t("p",[n._v("首先在 CreateDiv 构造函数中，把负责管理单例的代码移除出去，使它成为一个普通的创建 div 的类:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("    var CreateDiv = function( html ){\n      this.html = html;\n      this.init();\n    };\n    CreateDiv.prototype.init = function(){\n      var div = document.createElement( 'div' ); \n      div.innerHTML = this.html; \n      document.body.appendChild( div );\n    };\n")])])]),t("p",[n._v("接下来引入代理类 proxySingletonCreateDiv:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('  var ProxySingletonCreateDiv = (function() {\n    var instance;\n    return function(html) {\n      if (!instance) {\n        instance = new CreateDiv(html);\n      }\n      return instance;\n    };\n  })();\n  var a = new ProxySingletonCreateDiv("sven1");\n  var b = new ProxySingletonCreateDiv("sven2");\n  alert(a === b);\n')])])]),t("p",[n._v("通过引入代理类的方式，我们同样完成了一个单例模式的编写，\n跟之前不同的是，现在我们 把负责管理单例的逻辑移到了代理类 proxySingletonCreateDiv 中。\n这样一来，CreateDiv 就变成了 一个普通的类，它跟 proxySingletonCreateDiv 组合起来可以达到单例模式的效果。")]),n._v(" "),t("h3",{attrs:{id:"_3、javascript-中的单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、javascript-中的单例模式"}},[n._v("#")]),n._v(" 3、JavaScript 中的单例模式")]),n._v(" "),t("p",[n._v("JavaScript 是一门无类语言，单例模式的核心是确保只有一个实例，并提供全局访问。")]),n._v(" "),t("p",[n._v("全局变量不是单例模式，但在 JavaScript 开发中，我们经常会把全局变量当成单例来使用。\n例如:")]),n._v(" "),t("p",[n._v("var a = {};")]),n._v(" "),t("p",[n._v("但是全局变量存在很多问题，它很容易造成命名空间污染。\n在大中型项目中，如果不加以限 制和管理，程序中可能存在很多这样的变量。JavaScript 中的变量也很容易被不小心覆盖，\n相信每个 JavaScript 程序员都曾经历过变量冲突的痛苦，就像上面的对象 var a = {};，随时有可能被 别人覆盖。")]),n._v(" "),t("ul",[t("li",[n._v("使用命名空间")])]),n._v(" "),t("p",[n._v("适当地使用命名空间，并不会杜绝全局变量，但可以减少全局变量的数量。")]),n._v(" "),t("p",[n._v("最简单的方法依然是用对象字面量的方式:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("  var namespace1 = { \n    a: function() { \n      alert (1);\n    },\n    b: function() {\n      alert (2); \n    }\n  };\n")])])]),t("p",[n._v("把 a 和 b 都定义为 namespace1 的属性，这样可以减少变量和全局作用域打交道的机会。")]),n._v(" "),t("ul",[t("li",[n._v("使用闭包封装私有变量")])]),n._v(" "),t("p",[n._v("这种方法把一些变量封装在闭包的内部，只暴露一些接口跟外界通信:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('  var user = (function() {\n    var __name = "sven",\n      __age = 29;\n    return {\n      getUserInfo: function() {\n        return __name + "-" + __age;\n      }\n    };\n  })();\n')])])]),t("h3",{attrs:{id:"_4、惰性单例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、惰性单例"}},[n._v("#")]),n._v(" 4、惰性单例")]),n._v(" "),t("p",[n._v("惰性单例指的是在需要的时候才创建对象实例。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('  var createLoginLayer = (function() {\n    var div;\n    return function() {\n      if (!div) {\n        div = document.createElement("div");\n        div.innerHTML = "我是登录浮窗";\n        div.style.display = "none";\n        document.body.appendChild(div);\n      }\n      return div;\n    };\n  })();\n\n  document.getElementById("loginBtn").onclick = function() {\n    var loginLayer = createLoginLayer();\n    loginLayer.style.display = "block";\n  };\n')])])]),t("ul",[t("li",[n._v("通用的惰性单例")])]),n._v(" "),t("p",[n._v("这段代码仍然是违反单一职责原则的，创建对象和管理单例的逻辑都放在 createLoginLayer 对象内部。")]),n._v(" "),t("p",[n._v("如果我们下次需要创建页面中唯一的 iframe，或者 script 标签，用来跨域请求数据，就必须得如法炮制，把 createLoginLayer 函数几乎照抄一遍")]),n._v(" "),t("p",[n._v("现在我们就把如何管理单例的逻辑从原来的代码中抽离出来，\n这些逻辑被封装在 getSingle 函数内部，创建对象的方法 fn 被当成参数动态传入 getSingle 函数:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('  var getSingle = function(fn) {\n    var result;\n    return function() {\n      return result || (result = fn.apply(this, arguments));\n    };\n  };\n\n  var createLoginLayer = function() {\n    var div = document.createElement("div");\n    div.innerHTML = "我是登录浮窗";\n    div.style.display = "none";\n    document.body.appendChild(div);\n    return div;\n  };\n\n  var createSingleLoginLayer = getSingle(createLoginLayer);\n\n  document.getElementById("loginBtn").onclick = function() {\n    var loginLayer = createSingleLoginLayer();\n    loginLayer.style.display = "block";\n  };\n')])])]),t("p",[n._v("这种单例模式的用途远不止创建对象，比如我们通常渲染完页面中的一个列表之后，\n接下来要给这个列表绑定 click 事件，如果是通过 ajax 动态往列表里追加数据，在使用事件代理的前提\n下，click 事件实际上只需要在第一次渲染列表的时候被绑定一次。")]),n._v(" "),t("p",[n._v("利用 getSingle 函数，达到效果")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('  var bindEvent = getSingle(function() {\n    document.getElementById("div1").onclick = function() {\n      alert("click");\n    };\n    return true;\n  });\n\n  var render = function() {\n    console.log("开始渲染列表");\n    bindEvent();\n  };\n\n  render();\n  render();\n  render();\n')])])]),t("p",[n._v("// 可以看到，render 函数和 bindEvent 函数都分别执行了 3 次，但 div 实际上只被绑定了一个 事件。")]),n._v(" "),t("h2",{attrs:{id:"原型模式-（原型）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型模式-（原型）"}},[n._v("#")]),n._v(" ** 原型模式 （原型）**")]),n._v(" "),t("p",[n._v("** 对象把 "),t("code",[n._v("__proto__")]),n._v(" 委托给构造器的原型 **")]),n._v(" "),t("p",[n._v("JavaScript 给对象提供了一个名为 "),t("code",[n._v("__proto__")]),n._v(" 的隐藏属性， 某个对象的 "),t("code",[n._v("__proto__")]),n._v(" 默认会指向它的构造函数的原型对象，\n即 "),t("code",[n._v("(Constructor).prototype")]),n._v("。")]),n._v(" "),t("p",[n._v("在一些浏览器会暴露出来, 比如谷歌:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("  var a = new Object();\n  console.log(a.__proto__ === Object.prototype)\n")])])]),t("p",[n._v("可以通过原型访问当前对象没有的属性，当 "),t("code",[n._v("Object.prototype")]),n._v(" 也没有该属性的时候，\n它会像 Object.prototype 的原型上找，但是 Object.prototype 的原型是 "),t("code",[n._v("null")]),n._v("，\n说明这时候原型链后面已经没有其他原型了，这时候会返回 undefined。")]),n._v(" "),t("p",[n._v("当通过 Object.create(null) 可以创建出没有原型的对象。")])])}),[],!1,null,null,null);e.default=r.exports}}]);