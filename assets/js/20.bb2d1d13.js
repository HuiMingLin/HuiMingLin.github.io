(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{220:function(n,t,a){"use strict";a.r(t);var e=a(0),r=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"高阶函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数"}},[n._v("#")]),n._v(" 高阶函数")]),n._v(" "),a("p",[n._v("高阶函数是指至少满足下列条件之一的函数。")]),n._v(" "),a("ul",[a("li",[n._v("函数可以作为参数被传递")]),n._v(" "),a("li",[n._v("函数可以作为返回值输出")])]),n._v(" "),a("h3",{attrs:{id:"_1、函数作为参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、函数作为参数"}},[n._v("#")]),n._v(" 1、函数作为参数")]),n._v(" "),a("p",[n._v("像 ajax，promise，事件绑定，这些异步行为都会将函数作为回调函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('  $.ajax("http://xxx.com/api?", function(data) {\n    // do sth.\n  });\n\n  new Promise(function (resolve, reject) {\n    // do sth.\n  })\n\n  DOM.addEventListener(event type, function(){\n    // do sth.\n  })\n')])])]),a("p",[n._v("还有像 Array#sort, Array#map, Array#filter 都接受一个参数当做参数")]),n._v(" "),a("h3",{attrs:{id:"_2、函数作为返回值输出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、函数作为返回值输出"}},[n._v("#")]),n._v(" 2、函数作为返回值输出")]),n._v(" "),a("p",[n._v("最直接的例子就是 "),a("code",[n._v("函数式编程")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  var isType = function( type ){\n    return function( obj ) {\n      return Object.prototype.toString.call( obj ) === '[object '+ type +']';\n    }\n  };\n\n  var isString = isType( 'String' );\n  var isArray = isType( 'Array' );\n  var isNumber = isType( 'Number' );\n  console.log( isArray( [ 1, 2, 3 ] ) ); // true\n")])])]),a("h3",{attrs:{id:"高阶函数实现-aop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶函数实现-aop"}},[n._v("#")]),n._v(" 高阶函数实现 AOP")]),n._v(" "),a("p",[n._v("AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，\n这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。\n把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。\n这样做的好处首先是可以保持业务逻辑模块的。\n纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。")]),n._v(" "),a("p",[n._v("通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，\n本节我们通过扩展 Function.prototype 来做到这一点。代码如下:")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('  Function.prototype.before = function(beforefn) {\n    var __self = this; // 保存原函数的引用\n    return function() {\n      // 返回包含了原函数和新函数的"代理"函数\n      beforefn.apply(this, arguments);\n      return __self.apply(this, arguments);\n    };\n  };\n\n  Function.prototype.after = function(afterfn) {\n    var __self = this;\n    return function() {\n      // 执行新函数，修正 this // 执行原函数\n      var ret = __self.apply(this, arguments);\n      afterfn.apply(this, arguments);\n      return ret;\n    };\n  };\n\n  var func = function() {\n    console.log(2);\n  };\n\n  func = func\n    .before(function() {\n      console.log(1);\n    })\n    .after(function() {\n      console.log(3);\n    });\n\n  func();\n')])])]),a("h3",{attrs:{id:"_3、高阶函数的其他应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、高阶函数的其他应用"}},[n._v("#")]),n._v(" 3、高阶函数的其他应用")]),n._v(" "),a("ul",[a("li",[n._v("curry 柯里化")])]),n._v(" "),a("p",[n._v("柯里化被称为局部求值，函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来\n只有当传入的函数参数数量等于形参的时候，函数才会调用。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    var curryN = function(fn) {\n      var args = []];\n      return function curryed() {\n        var innerArgs = [].slice.call(arguments);\n        args = args.concat(innerArgs);\n        if (fn.length <= args.length) {\n          return fn.apply(this, args);\n        } else {\n          return curryed;\n        }\n      };\n    };\n")])])]),a("ul",[a("li",[n._v("uncurry\n一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢?")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('  var obj1 = { name: "sven" };\n  var obj2 = {\n    getName: function() {\n      return this.name;\n    }\n  };\n  console.log(obj2.getName.call(obj1));  // 输出:sven\n')])])]),a("p",[n._v("这是最常用的，但是如何转换 getName 转换为通用的函数呢？")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  Function.prototype.uncurrying = function() {\n    var self = this;\n    return function() {\n      var obj = Array.prototype.shift.call(arguments);\n      return self.apply(obj, arguments);\n    };\n  };\n\n  var getName = obj2.getName.uncurrying();\n  console.log(getName(obj1))\n")])])]),a("p",[n._v("另一种写法：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  Function.prototype.uncurrying = function(){\n    var self = this;\n    return function () {\n      return Function.prototype.call.apply( self, arguments );\n    }\n  };\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);