import{_ as e,c as t,o as a,a1 as d}from"./chunks/framework.DwaB85k5.js";const p=JSON.parse('{"title":"生命周期","description":"","frontmatter":{"menu":"Vue"},"headers":[],"relativePath":"basic/vue/vue2/life-cycle.md","filePath":"basic/vue/vue2/life-cycle.md","lastUpdated":1717270930000}'),r={name:"basic/vue/vue2/life-cycle.md"},o=d('<h1 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h1><p>生命周期（Life Cycle）的概念应用很广泛，特别是在政治、经济、环境、技术、社会等诸多领域经常出现，其基本涵义可以通俗地理解为“从摇篮到坟墓”（Cradle-to-Grave）的整个过程</p><p>在 Vue 中实例从创建到销毁的过程就是生命周期，即指从创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列过程</p><p>我们可以把组件比喻成工厂里面的一条流水线，每个工人（生命周期）站在各自的岗位，当任务流转到工人身边的时候，工人就开始工作</p><p>PS：在 Vue 生命周期钩子会自动绑定 this 上下文到实例中，因此你可以访问数据，对 property 和方法进行运算这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())</p><h2 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h2><p>Vue 生命周期总共可以分为 8 个阶段：创建前后, 载入前后,更新前后,销毁前销毁后，以及一些特殊场景的生命周期</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初,执行时组件实例还未创建，通常用于插件开发中执行一些初始化任务</td></tr><tr><td>created</td><td>组件实例已经完全创建,组件初始化完毕，各种数据可以使用，常用于异步数据获取</td></tr><tr><td>beforeMount</td><td>组件挂载之前,未执行渲染、更新，dom 未创建</td></tr><tr><td>mounted</td><td>组件挂载到实例上去之后,初始化结束，dom 已创建，可用于获取访问数据和 dom 元素</td></tr><tr><td>beforeUpdate</td><td>组件数据发生变化，更新之前,更新前，可用于获取更新前各种状态</td></tr><tr><td>updated</td><td>组件数据更新之后,更新后，所有状态已是最新</td></tr><tr><td>beforeDestroy</td><td>组件实例销毁之前,销毁前，可用于一些定时器或订阅的取消</td></tr><tr><td>destroyed</td><td>组件实例销毁之后,组件已销毁，作用同上</td></tr><tr><td>activated</td><td>keep-alive 缓存的组件激活时</td></tr><tr><td>deactivated</td><td>keep-alive 缓存的组件停用时调用</td></tr><tr><td>errorCaptured</td><td>捕获一个来自子孙组件的错误时被调用</td></tr></tbody></table><h2 id="整体流程" tabindex="-1">整体流程 <a class="header-anchor" href="#整体流程" aria-label="Permalink to &quot;整体流程&quot;">​</a></h2><h3 id="beforecreate-created" tabindex="-1">beforeCreate -&gt; created <a class="header-anchor" href="#beforecreate-created" aria-label="Permalink to &quot;beforeCreate -&gt; created&quot;">​</a></h3><p>初始化 vue 实例，进行数据观测</p><h3 id="created" tabindex="-1">created <a class="header-anchor" href="#created" aria-label="Permalink to &quot;created&quot;">​</a></h3><ul><li>完成数据观测，属性与方法的运算，watch、event 事件回调的配置</li><li>可调用 methods 中的方法，访问和修改 data 数据触发响应式渲染 dom，可通过 computed 和 watch 完成数据计算</li><li>此时 vm.$el 并没有被创建</li></ul><h3 id="created-beforemount" tabindex="-1">created -&gt; beforeMount <a class="header-anchor" href="#created-beforemount" aria-label="Permalink to &quot;created -&gt; beforeMount&quot;">​</a></h3><ul><li>判断是否存在 el 选项，若不存在则停止编译，直到调用 vm.$mount(el)才会继续编译</li><li>优先级：render &gt; template &gt; outerHTML</li><li>vm.el 获取到的是挂载 DOM 的</li></ul><h3 id="beforemount" tabindex="-1">beforeMount <a class="header-anchor" href="#beforemount" aria-label="Permalink to &quot;beforeMount&quot;">​</a></h3><ul><li>在此阶段可获取到 vm.el</li><li>此阶段 vm.el 虽已完成 DOM 初始化，但并未挂载在 el 选项上</li></ul><h3 id="beforemount-mounted" tabindex="-1">beforeMount -&gt; mounted <a class="header-anchor" href="#beforemount-mounted" aria-label="Permalink to &quot;beforeMount -&gt; mounted&quot;">​</a></h3><p>此阶段 vm.el 完成挂载，vm.$el 生成的 DOM 替换了 el 选项所对应的 DOM</p><h3 id="mounted" tabindex="-1">mounted <a class="header-anchor" href="#mounted" aria-label="Permalink to &quot;mounted&quot;">​</a></h3><p>vm.el 已完成 DOM 的挂载与渲染，此刻打印 vm.$el，发现之前的挂载点及内容已被替换成新的 DOM</p><h3 id="beforeupdate" tabindex="-1">beforeUpdate <a class="header-anchor" href="#beforeupdate" aria-label="Permalink to &quot;beforeUpdate&quot;">​</a></h3><ul><li>更新的数据必须是被渲染在模板上的（el、template、render 之一）</li><li>此时 view 层还未更新</li><li>若在 beforeUpdate 中再次修改数据，不会再次触发更新方法</li></ul><h3 id="updated" tabindex="-1">updated <a class="header-anchor" href="#updated" aria-label="Permalink to &quot;updated&quot;">​</a></h3><ul><li>完成 view 层的更新</li><li>若在 updated 中再次修改数据，会再次触发更新方法（beforeUpdate、updated）</li></ul><h3 id="beforedestroy" tabindex="-1">beforeDestroy <a class="header-anchor" href="#beforedestroy" aria-label="Permalink to &quot;beforeDestroy&quot;">​</a></h3><p>实例被销毁前调用，此时实例属性与方法仍可访问</p><h3 id="destroyed" tabindex="-1">destroyed <a class="header-anchor" href="#destroyed" aria-label="Permalink to &quot;destroyed&quot;">​</a></h3><ul><li>完全销毁一个实例。可清理它与其它实例的连接，解绑它的全部指令及事件监听器</li><li>并不能清除 DOM，仅仅销毁实例</li></ul><h2 id="数据请求在-created-和-mouted-的区别" tabindex="-1">数据请求在 created 和 mouted 的区别 <a class="header-anchor" href="#数据请求在-created-和-mouted-的区别" aria-label="Permalink to &quot;数据请求在 created 和 mouted 的区别&quot;">​</a></h2><p>created 是在组件实例一旦创建完成的时候立刻调用，这时候页面 dom 节点并未生成；</p><p>mounted 是在页面 dom 节点渲染完毕之后就立刻执行的。触发时机上 created 是比 mounted 要更早的，</p><p>两者的相同点：都能拿到实例对象的属性和方法。</p><p>讨论这个问题本质就是触发的时机，放在 mounted 中的请求有可能导致页面闪动（因为此时页面 dom 结构已经生成），但如果在页面加载前完成请求，则不会出现此情况。建议对页面内容的改动放在 created 生命周期当中。</p>',34),l=[o];function i(u,n,h,c,m,s){return a(),t("div",null,l)}const f=e(r,[["render",i]]);export{p as __pageData,f as default};
