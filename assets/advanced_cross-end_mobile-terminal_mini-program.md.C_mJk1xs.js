import{_ as a,c as n,o as l,a1 as e}from"./chunks/framework.DwaB85k5.js";const s="/assets/architecture.n00zey9d.png",i="/assets/dom-mounte.BeN0wzjp.png",p="/assets/patch.CvdDsgdm.png",r="/assets/load.Btaukh50.png",t="/assets/pay-overview.CdjHlapf.png",o="/assets/pay-flow.DWraTwzo.png",d="/assets/pay-params.LtdSDomu.webp",c="/assets/login.QyNWFW2G.png",_=JSON.parse('{"title":"微信小程序","description":"","frontmatter":{"menu":"mobile-terminal"},"headers":[],"relativePath":"advanced/cross-end/mobile-terminal/mini-program.md","filePath":"advanced/cross-end/mobile-terminal/mini-program.md","lastUpdated":1717275443000}'),h={name:"advanced/cross-end/mobile-terminal/mini-program.md"},u=e('<h1 id="微信小程序" tabindex="-1">微信小程序 <a class="header-anchor" href="#微信小程序" aria-label="Permalink to &quot;微信小程序&quot;">​</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>在传统的网页开发中，渲染线程和脚本是互斥的，这也是为什么长时间的脚本运行可能会导致页面失去响应的原因，因为我们常说的 JS 是单线程的。而微信小程序则选用了 Hybrid 的渲染方式，将视图层和逻辑层分开，实现双线程同时运行。在此模式下，视图层的界面使用 WebView 进行渲染，而逻辑层则在 JSCore 中运行。</p><p><img src="'+s+'" alt="alt 属性文本"></p><p>在小程序中，渲染层主要负责界面渲染相关的任务，并在 WebView 线程里执行。一个小程序可能存在多个界面，所以渲染层存在多个 WebView 线程。而逻辑层则采用 JsCore 线程运行 JS 脚本，执行的都是与小程序业务逻辑有关的代码。</p><h2 id="由来" tabindex="-1">由来 <a class="header-anchor" href="#由来" aria-label="Permalink to &quot;由来&quot;">​</a></h2><p>当微信中的WebView逐渐成为移动Web的一个重要入口时,微信就有相关的JS-SDK。JS-SDK解决了移动网页能力不足的问题,但没有解决体验不良的问题。</p><p>为此,小程序应运而生,具有:</p><ul><li>快速加载</li><li>更强大的能力</li><li>原生体验</li><li>易用的微信数据开放</li><li>高效简单的开发</li></ul><p>小程序页面本质上是网页,技术模型与H5类似,只是自定义了WXML标签。</p><h2 id="通信" tabindex="-1">通信 <a class="header-anchor" href="#通信" aria-label="Permalink to &quot;通信&quot;">​</a></h2><p>在小程序的渲染层，宿主环境会将wxml转化成对应的JS对象。当逻辑层的数据发生变更时，通过宿主环境提供的setData方法，数据就可以从逻辑层传递到渲染层。然后通过对比数据变化前后的差异，将差异应用在原来的Dom树上，从而渲染出正确的视图。</p><p><img src="'+i+'" alt="alt 属性文本"></p><p>由于小程序是基于双线程的，因此在视图层和逻辑层之间的任何数据传递都是线程间的通信，会有一定的延时。所以在小程序中，页面更新成了异步操作。异步会使得各部分的运行时序变得复杂一些，逻辑层与渲染层需要有一定的机制保证时序正确，在每个小程序页面的生命周期中，存在着若干次页面数据通信。</p><p><img src="'+p+'" alt="alt 属性文本"></p><h2 id="运行机制" tabindex="-1">运行机制 <a class="header-anchor" href="#运行机制" aria-label="Permalink to &quot;运行机制&quot;">​</a></h2><p>小程序启动运行主要有两种情况：</p><ul><li>冷启动（重新开始）：用户首次打开或者小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动，即为冷启动</li><li>热启动：用户已经打开过小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需要将后台态的小程序切换到前台，这个过程就是热启动</li></ul><p>需要注意的是：</p><ul><li>小程序没有重启的概念</li><li>当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后会被微信主动销毁</li><li>短时间内收到系统两次以上内存警告，也会对小程序进行销毁，这也就为什么一旦页面内存溢出，页面会奔溃的本质原因了</li></ul><p><img src="'+r+'" alt="alt 属性文本"></p><h2 id="支付流程" tabindex="-1">支付流程 <a class="header-anchor" href="#支付流程" aria-label="Permalink to &quot;支付流程&quot;">​</a></h2><p>流程大致如下：</p><ul><li>用户通过分享或扫描二维码进入商户小程序，用户选择购买，完成选购流程。</li><li>调起微信支付控件，用户开始输入支付密码。</li><li>密码验证通过，支付成功。商户后台得到支付成功的通知。</li><li>返回商户小程序，显示购买成功。</li><li>微信支付公众号下发支付凭证。</li></ul><p><img src="'+t+'" alt="alt 属性文本"></p><h3 id="详细流程" tabindex="-1">详细流程 <a class="header-anchor" href="#详细流程" aria-label="Permalink to &quot;详细流程&quot;">​</a></h3><p>以电商小程序为例，支付流程图如下：</p><p><img src="'+o+`" alt="alt 属性文本"></p><p>具体操作流程如下：</p><ul><li>打开小程序，点击直接下单。此时，小程序会调用wx.login获取用户临时登录凭证code，然后发送到后端服务器换取openId。</li><li>用户下单，小程序需要将购买的商品Id，商品数量，以及用户的openId传送到服务器。</li><li>服务器在接收到商品Id、商品数量、openId后，生成订单数据。同时，通过签名算法，向微信支付发送请求，获取预付单信息（prepay_id）。然后，服务器会将获取的数据再次进行签名，向小程序端响应必要的信息。</li><li>小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付。</li><li>接下来，用户会进行微信支付密码、指纹等验证。确认支付之后，微信后台进行鉴权，直接返回给前端支付的结果。前端收到返回数据后对支付结果进行展示。</li><li>最后，微信后台在给前端返回支付的结果后，也会向后台返回一个支付结果。后台通过这个支付结果来更新订单的状态。</li></ul><p>以下是后端响应数据和wx.requestPayment方法所需要的参数示例：</p><div class="language-wx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">wx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>wx.requestPayment({</span></span>
<span class="line"><span>  // 时间戳</span></span>
<span class="line"><span>  timeStamp: &#39;&#39;,</span></span>
<span class="line"><span>  // 随机字符串</span></span>
<span class="line"><span>  nonceStr: &#39;&#39;,</span></span>
<span class="line"><span>  // 统一下单接口返回的 prepay_id 参数值</span></span>
<span class="line"><span>  package: &#39;&#39;,</span></span>
<span class="line"><span>  // 签名类型</span></span>
<span class="line"><span>  signType: &#39;&#39;,</span></span>
<span class="line"><span>  // 签名</span></span>
<span class="line"><span>  paySign: &#39;&#39;,</span></span>
<span class="line"><span>  // 调用成功回调</span></span>
<span class="line"><span>  success () {},</span></span>
<span class="line"><span>  // 失败回调</span></span>
<span class="line"><span>  fail () {},</span></span>
<span class="line"><span>  // 接口调用结束回调</span></span>
<span class="line"><span>  complete () {}</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>参数表如下所示：</p><p><img src="`+d+`" alt="alt 属性文本"></p><h3 id="支付安全" tabindex="-1">支付安全 <a class="header-anchor" href="#支付安全" aria-label="Permalink to &quot;支付安全&quot;">​</a></h3><p>对于支付的安全，微信小程序采用了多重安全措施。</p><ul><li><p>首先，微信支付是基于HTTPS传输加密数据，采用安全协议来保证信息传输的安全性。</p></li><li><p>其次，微信支付服务提供了商户证书下发、报文签名以及商户数据包（MD5）校验等多种安全机制来防止信息被篡改。</p></li><li><p>此外，用户的支付信息如银行卡号、密码、验证码等信息均不会保存在商户系统或者微信系统，即使在微信服务器被攻破，也无法获取用户的真实支付信息。</p></li><li><p>最后，微信支付还为用户提供了交易过程中的安全保障，通过多种风险控制系统为用户拦截可疑交易。</p></li></ul><h2 id="优化速度" tabindex="-1">优化速度 <a class="header-anchor" href="#优化速度" aria-label="Permalink to &quot;优化速度&quot;">​</a></h2><h3 id="加载优化" tabindex="-1">加载优化 <a class="header-anchor" href="#加载优化" aria-label="Permalink to &quot;加载优化&quot;">​</a></h3><ul><li>控制代码包体积,及时清理无用代码</li><li>使用子包按需加载,减少主包体积</li><li>预加载子包,避免首次点击卡顿</li></ul><h3 id="渲染优化" tabindex="-1">渲染优化 <a class="header-anchor" href="#渲染优化" aria-label="Permalink to &quot;渲染优化&quot;">​</a></h3><ul><li>onLoad阶段发请求,不等待onReady</li><li>缓存本地数据,减少不必要的网络请求</li><li>合并setData调用,避免频繁刷新界面</li><li>抽离自定义组件,减少主界面渲染压力</li></ul><h3 id="首屏优化" tabindex="-1">首屏优化 <a class="header-anchor" href="#首屏优化" aria-label="Permalink to &quot;首屏优化&quot;">​</a></h3><ul><li>预请求数据,利用缓存数据构建首屏</li><li>采用骨架屏 placeholders 占位</li><li>提前预加载资源包</li></ul><h3 id="启动优化" tabindex="-1">启动优化 <a class="header-anchor" href="#启动优化" aria-label="Permalink to &quot;启动优化&quot;">​</a></h3><ul><li>显示加载图标避免白屏</li><li>合理制定启动图片大小</li></ul><h3 id="长列表优化" tabindex="-1">长列表优化 <a class="header-anchor" href="#长列表优化" aria-label="Permalink to &quot;长列表优化&quot;">​</a></h3><ul><li>虚拟列表,减少DOM节点</li><li>预加载可视区域外图片</li><li>图片懒加载,滚动到可视区再加载</li></ul><h3 id="打包策略" tabindex="-1">打包策略 <a class="header-anchor" href="#打包策略" aria-label="Permalink to &quot;打包策略&quot;">​</a></h3><ul><li>压缩代码,上传时启用代码压缩</li><li>按功能拆分子包</li><li>删除无用文件,精简资源体积</li></ul><h2 id="路由跳转" tabindex="-1">路由跳转 <a class="header-anchor" href="#路由跳转" aria-label="Permalink to &quot;路由跳转&quot;">​</a></h2><h3 id="wx-navigateto" tabindex="-1">wx.navigateTo <a class="header-anchor" href="#wx-navigateto" aria-label="Permalink to &quot;wx.navigateTo&quot;">​</a></h3><p>保留当前页面,跳转到应用内的某个页面。可以使用wx.navigateBack回到原页面。</p><p>特点:页面栈增多,占用内存。</p><p>参数:</p><div class="language-wx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">wx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  url: &#39;test?id=1&#39; // 需要跳转的应用内非 tabBar 的页面的路径</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="wx-redirectto" tabindex="-1">wx.redirectTo <a class="header-anchor" href="#wx-redirectto" aria-label="Permalink to &quot;wx.redirectTo&quot;">​</a></h3><p>关闭当前页面,跳转到应用内的某个页面。</p><p>特点:不能回到原页面,页面栈不增加。</p><p>参数:</p><div class="language-wx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">wx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  url: &#39;test?id=1&#39; // 需要跳转的应用内非 tabBar 的页面的路径</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="wx-navigateback" tabindex="-1">wx.navigateBack <a class="header-anchor" href="#wx-navigateback" aria-label="Permalink to &quot;wx.navigateBack&quot;">​</a></h3><p>关闭当前页面,返回上一页面或多级页面。</p><p>特点:页面栈逐级退出,减少内存占用。</p><p>参数:</p><div class="language-wx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">wx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  delta: 1 // 返回的页面数</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="wx-relaunch" tabindex="-1">wx.reLaunch <a class="header-anchor" href="#wx-relaunch" aria-label="Permalink to &quot;wx.reLaunch&quot;">​</a></h3><p>关闭所有页面,打开到应用内的某个页面。</p><p>特点:页面栈清空只留下新的页面。</p><p>参数:</p><div class="language-wx vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">wx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>{</span></span>
<span class="line"><span>  url: &#39;test&#39; // 需要跳转的页面路径 </span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="登录" tabindex="-1">登录 <a class="header-anchor" href="#登录" aria-label="Permalink to &quot;登录&quot;">​</a></h2><h3 id="获取code" tabindex="-1">获取code <a class="header-anchor" href="#获取code" aria-label="Permalink to &quot;获取code&quot;">​</a></h3><ul><li><p>用户在小程序内点击登录按钮</p></li><li><p>调用wx.login()获取code</p></li></ul><h3 id="获取openid" tabindex="-1">获取openid <a class="header-anchor" href="#获取openid" aria-label="Permalink to &quot;获取openid&quot;">​</a></h3><ul><li><p>将code发送到开发者服务器</p></li><li><p>开发者服务器使用code向微信服务器获取openid和session_key</p></li></ul><h3 id="校验openid" tabindex="-1">校验openid <a class="header-anchor" href="#校验openid" aria-label="Permalink to &quot;校验openid&quot;">​</a></h3><ul><li><p>开发者服务器拿到openid,去数据库查询是否已存在</p></li><li><p>若不存在,表示新用户,创建新记录</p></li><li><p>若存在,校验用户信息,生成自定义登录态</p></li></ul><h3 id="返回登录态" tabindex="-1">返回登录态 <a class="header-anchor" href="#返回登录态" aria-label="Permalink to &quot;返回登录态&quot;">​</a></h3><ul><li><p>开发者服务器将登录态返回给小程序</p></li><li><p>小程序存储登录态到本地</p></li></ul><h3 id="校验登录态" tabindex="-1">校验登录态 <a class="header-anchor" href="#校验登录态" aria-label="Permalink to &quot;校验登录态&quot;">​</a></h3><ul><li><p>小程序重新启动时可校验登录态</p></li><li><p>调用wx.checkSessionAPI验证登录态是否过期</p></li><li><p>过期则重新执行登录流程,未过期则继续使用</p></li></ul><p><img src="`+c+'" alt="alt 属性文本"></p><h2 id="生命周期" tabindex="-1">生命周期 <a class="header-anchor" href="#生命周期" aria-label="Permalink to &quot;生命周期&quot;">​</a></h2><h3 id="应用生命周期" tabindex="-1">应用生命周期 <a class="header-anchor" href="#应用生命周期" aria-label="Permalink to &quot;应用生命周期&quot;">​</a></h3><p>应用生命周期函数定义在app.js中</p><ul><li>onLaunch 小程序初始化完成时触发(全局只触发一次)</li><li>onShow 小程序启动,或从后台进入前台显示时触发</li><li>onHide 小程序从前台进入后台时触发</li><li>onError 小程序发生脚本错误或API调用报错时触发</li><li>onPageNotFound 小程序要打开的页面不存在时触发</li><li>onUnhandledRejection 小程序有未处理的Promise拒绝时触发</li><li>onThemeChange 系统切换主题时触发</li></ul><h3 id="页面生命周期" tabindex="-1">页面生命周期 <a class="header-anchor" href="#页面生命周期" aria-label="Permalink to &quot;页面生命周期&quot;">​</a></h3><p>页面生命周期函数在page.js中定义。</p><ul><li>onLoad 页面加载时触发 用于加载页面数据</li><li>onShow 页面显示时触发 页面重新显示时刷新数据</li><li>onReady 页面初次渲染完成时触发 获取页面 DOM 节点</li><li>onHide 页面隐藏时触发 停止页面动画或计时器等</li><li>onUnload 页面卸载时触发 停止网络请求或清理订阅等</li></ul><h3 id="组件生命周期" tabindex="-1">组件生命周期 <a class="header-anchor" href="#组件生命周期" aria-label="Permalink to &quot;组件生命周期&quot;">​</a></h3><p>组件生命周期函数在component.js中定义。</p><ul><li>created 组件实例刚创建时触发</li><li>attached 组件进入页面节点树时触发</li><li>ready 组件首次渲染完成时触发</li><li>moved 组件位置改变时触发</li><li>detached 组件离开页面节点树时触发</li><li>error 组件方法错误时触发</li></ul><h3 id="执行顺序" tabindex="-1">执行顺序 <a class="header-anchor" href="#执行顺序" aria-label="Permalink to &quot;执行顺序&quot;">​</a></h3><p>一个典型的完整生命周期顺序为:</p><ul><li><p>小程序打开:onLaunch -&gt; onShow -&gt; onLoad -&gt; onShow -&gt; onReady</p></li><li><p>进入新页面:onHide -&gt; onLoad -&gt; onShow -&gt; onReady</p></li><li><p>返回上一页:onUnload -&gt; onShow</p></li><li><p>小程序切后台:onHide</p></li><li><p>小程序重启:onLaunch -&gt; onShow</p></li></ul><h2 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h2><p>优点:</p><ul><li>随用随走,代替许多APP</li><li>借助平台流量,易被接受</li><li>相对安全</li><li>开发门槛低</li><li>降低兼容性限制</li></ul><p>缺点:</p><ul><li>用户留存率不高</li><li>体积限制,无法开发大型小程序</li><li>受限于微信管控,自由度较低</li></ul><p>微信小程序结合了APP和网页的优点,为用户和开发者带来便利,但也存在自身的限制。以其便捷性为先,逐步优化体验,或可成为移动端一个重要的形式。</p>',102),b=[u];function m(g,x,q,k,w,v){return l(),n("div",null,b)}const f=a(h,[["render",m]]);export{_ as __pageData,f as default};
