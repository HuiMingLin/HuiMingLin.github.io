import{_ as s,c as n,o as e,a1 as a}from"./chunks/framework.DwaB85k5.js";const m=JSON.parse('{"title":"Service Worker","description":"","frontmatter":{"menu":"性能优化","name":"service worker"},"headers":[],"relativePath":"advanced/browser/service-worker.md","filePath":"advanced/browser/service-worker.md","lastUpdated":1717275443000}'),p={name:"advanced/browser/service-worker.md"},r=a(`<h1 id="service-worker" tabindex="-1">Service Worker <a class="header-anchor" href="#service-worker" aria-label="Permalink to &quot;Service Worker&quot;">​</a></h1><p>丰富的离线体验、定期的后台同步以及推送通知等通常需要将面向本机应用的功能将引入到网页应用中。 Service Worker 提供所有这些功能所依赖的技术基础。</p><p><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能， 它们已包括如 <code>推送通知</code> 和 <code>后台同步</code> 等功能。 使用 Service Worker 的话，传输协议必须为 <code>HTTPS</code>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 相关注意事项：</p><p>-它是一种 <code>JavaScript Worker</code>，无法直接访问 DOM。 Service Worker 通过响应 <code>postMessage</code> 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。 -Service Worker 是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。 -Service Worker 在不用时会被中止，并在下次有需要时重启， 因此，您不能依赖 Service Worker onfetch 和 onmessage 处理程序中的全局状态。 如果存在您需要持续保存并在重启后加以重用的信息，Service Worker 可以访问 <code>IndexedDB API</code>。 -Service Worker 广泛地利用了 promise</p><h4 id="service-worker-生命周期" tabindex="-1">Service Worker 生命周期 <a class="header-anchor" href="#service-worker-生命周期" aria-label="Permalink to &quot;Service Worker 生命周期&quot;">​</a></h4><p>目的：</p><ul><li>实现离线优先。</li><li>允许新 Service Worker 自行做好运行准备，无需中断当前的 Service Worker。</li><li>确保整个过程中作用域页面由同一个 Service Worker（或者没有 Service Worker）控制。</li><li>确保每次只运行网站的一个版本。</li></ul><p>最后一点非常重要。如果没有 Service Worker，用户可以将一个标签加载到您的网站，稍后打开另一个标签。 这会导致同时运行网站的两个版本。有时候这样做没什么问题，但如果您正在处理存储， 那么，出现两个标签很容易会让您的操作中断，因为它们的共享的存储空间管理机制大相径庭。 这可能会导致错误，更糟糕的情况是导致数据丢失。</p><p>Service Worker 的生命周期完全独立于网页。</p><p>要为网站安装服务工作线程，您需要先在页面的 JavaScript 中注册。 注册服务工作线程将会使浏览器在后台启动服务工作线程安装步骤。</p><p>在安装过程中，您通常需要缓存某些静态资产。 如果所有文件均已成功缓存，那么 Service Worker 就安装完毕。 如果任何文件下载失败或缓存失败，那么安装步骤将会失败，Service Worker 就无法激活（也就是说， 不会安装）。 如果发生这种情况，不必担心，它下次会再试一次。 但这意味着，如果安装完成，您可以知道您已在缓存中获得那些静态资产。</p><p>安装之后，接下来就是激活步骤，这是管理旧缓存的绝佳机会，我们将在 Service Worker 的更新部分对此详加介绍。</p><p>激活之后，Service Worker 将会对其作用域内的所有页面实施控制，不过，首次注册该 Service Worker 的页面需要再次加载才会受其控制。 服务工作线程实施控制后，它将处于以下两种状态之一：</p><ul><li>服务工作线程终止以节省内存</li><li>处理获取和消息事件，从页面发出网络请求或消息</li></ul><p>以下是 Service Worker 初始安装时的简化生命周期。</p><h4 id="先决条件" tabindex="-1">先决条件 <a class="header-anchor" href="#先决条件" aria-label="Permalink to &quot;先决条件&quot;">​</a></h4><p><strong>浏览器支持</strong></p><p>可用的浏览器日益增多。 Service Worker 受 Chrome、Firefox 和 Opera 支持。 Microsoft Edge 现在表示公开支持。 甚至 Safari 也暗示未来会进行相关开发。 您可以在 Jake Archibald 的 is Serviceworker ready 网站上查看所有浏览器的支持情况 。</p><p><strong>您需要 HTTPS</strong></p><p>在开发过程中，可以通过 localhost 使用 Service Worker，但如果要在网站上部署 Service Worker，则需要在服务器上设置 HTTPS。</p><p>使用服务工作线程，您可以劫持连接、编撰以及过滤响应。 这是一个很强大的工具。 您可能会善意地使用这些功能，但中间人可会将其用于不良目的。 为避免这种情况，可仅在通过 HTTPS 提供的页面上注册 Service Worker， 如此我们便知道浏览器接收的 Service Worker 在整个网络传输过程中都没有被篡改。</p><p>Github 页面 通过 HTTPS 提供，因此这些页面是托管演示的绝佳位置。</p><p>如果想要向服务器添加 HTTPS，您需要获得 TLS 证书并在服务器上进行设置。</p><p>Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、 如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p><p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件， 那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 以下是这个步骤的实现：</p><h4 id="注册-service-worker" tabindex="-1">注册 Service Worker <a class="header-anchor" href="#注册-service-worker" aria-label="Permalink to &quot;注册 Service Worker&quot;">​</a></h4><p>若要安装 Service Worker，您需要通过在页面中对其进行注册来启动安装。 这将告诉浏览器 Service Worker JavaScript 文件的位置。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  if (&#39;serviceWorker&#39; in navigator) {</span></span>
<span class="line"><span>    window.addEventListener(&#39;load&#39;, function() {</span></span>
<span class="line"><span>      navigator.serviceWorker.register(&#39;/sw.js&#39;).then(function(registration) {</span></span>
<span class="line"><span>        // Registration was successful</span></span>
<span class="line"><span>        console.log(&#39;ServiceWorker registration successful with scope: &#39;, registration.scope);</span></span>
<span class="line"><span>      }, function(err) {</span></span>
<span class="line"><span>        // registration failed :(</span></span>
<span class="line"><span>        console.log(&#39;ServiceWorker registration failed: &#39;, err);</span></span>
<span class="line"><span>      });</span></span>
<span class="line"><span>    });</span></span>
<span class="line"><span>  }</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>此代码用于检查 Service Worker API 是否可用，如果可用，则在 <code>页面加载后注册</code> 位于 /sw.js 的 Service Worker。</p><p>每次页面加载无误时，即可调用 register()；浏览器将会判断服务工作线程是否已注册并做出相应的处理。</p><p>register() 方法的精妙之处在于服务工作线程文件的位置。 您会发现在本例中服务工作线程文件位于根网域。 这意味着服务工作线程的作用域将是整个来源。 换句话说，Service Worker 将接收此网域上所有事项的 fetch 事件。 如果我们在 <code>/example/sw.js</code> 处注册 Service Worker 文件， 则 Service Worker 将只能看到网址以 /example/ 开头（即 /example/page1/、/example/page2/）的页面的 fetch 事件。 上面是 <code>/sw.js</code></p><h4 id="安装-service-worker" tabindex="-1">安装 Service Worker <a class="header-anchor" href="#安装-service-worker" aria-label="Permalink to &quot;安装 Service Worker&quot;">​</a></h4><p>在受控页面启动注册流程后，我们来看看处理 install 事件的 Service Worker 脚本。</p><p>最基本的例子是，您需要为安装事件定义回调，并决定想要缓存的文件。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  self.addEventListener(&#39;install&#39;, function(event) {</span></span>
<span class="line"><span>    // Perform install steps</span></span>
<span class="line"><span>  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>在 install 回调的内部，我们需要执行以下步骤：</p><p>-打开缓存 -缓存文件 -确认所有需要的资产是否已缓存</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  var CACHE_NAME = &#39;my-site-cache-v1&#39;;</span></span>
<span class="line"><span>  var urlsToCache = [</span></span>
<span class="line"><span>    &#39;/&#39;,</span></span>
<span class="line"><span>    &#39;/styles/main.css&#39;,</span></span>
<span class="line"><span>    &#39;/script/main.js&#39;</span></span>
<span class="line"><span>  ];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  self.addEventListener(&#39;install&#39;, function(event) {</span></span>
<span class="line"><span>    // Perform install steps</span></span>
<span class="line"><span>    event.waitUntil(</span></span>
<span class="line"><span>      caches.open(CACHE_NAME)</span></span>
<span class="line"><span>        .then(function(cache) {</span></span>
<span class="line"><span>          console.log(&#39;Opened cache&#39;);</span></span>
<span class="line"><span>          return cache.addAll(urlsToCache);</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>    );</span></span>
<span class="line"><span>  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>此处，我们以所需的缓存名称调用 caches.open()，之后再调用 cache.addAll() 并传入文件数组。 这是一个 promise 链（caches.open() 和 cache.addAll()）。 event.waitUntil() 方法带有 promise 参数并使用它来判断安装所花费的时间，以及安装是否成功。</p><p>如果所有文件都成功缓存，则将安装 Service Worker。 如有任何文件无法下载，则安装步骤将失败。 这可让您依赖于所定义的所有资产，但也意味着需要对您决定在安装步骤缓存的文件列表格外留意。 定义一个过长的文件列表将会增加文件缓存失败的几率，从而导致服务工作线程未能安装。</p><p>这仅是一个示例，实际您可以在 install 事件中执行其他任务，或完全避免设置 install 事件侦听器</p><h4 id="缓存和返回请求" tabindex="-1">缓存和返回请求 <a class="header-anchor" href="#缓存和返回请求" aria-label="Permalink to &quot;缓存和返回请求&quot;">​</a></h4><p>您已安装 Service Worker，现在可能会想要返回一个缓存的响应，对吧？</p><p>在安装 Service Worker 且用户转至其他页面或刷新当前页面后，Service Worker 将开始接收 fetch 事件。下面提供了一个示例</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  self.addEventListener(&#39;fetch&#39;, function (event) {</span></span>
<span class="line"><span>    console.log(event);</span></span>
<span class="line"><span>    event.respondWith(</span></span>
<span class="line"><span>      caches.match(event.request).then(function (response) {</span></span>
<span class="line"><span>        // Cache hit - return response</span></span>
<span class="line"><span>        if (response) {</span></span>
<span class="line"><span>          return response</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        return fetch(event.request)</span></span>
<span class="line"><span>      })</span></span>
<span class="line"><span>    )</span></span>
<span class="line"><span>  })</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>这里我们定义了 fetch 事件，并且在 event.respondWith() 中，我们传入来自 caches.match() 的一个 promise。 此方法检视该请求，并从服务工作线程所创建的任何缓存中查找缓存的结果。</p><p>如果发现匹配的响应，则返回缓存的值，否则，将调用 fetch 以发出网络请求，并将从网络检索到的任何数据作为结果返回。 这是一个简单的例子，它使用了在安装步骤中缓存的所有资产。</p><p>如果希望连续缓存新请求，可以通过处理 fetch 请求的响应并将其添加到缓存来实现，如下所示</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>  self.addEventListener(&#39;fetch&#39;, function(event) {</span></span>
<span class="line"><span>    event.respondWith(</span></span>
<span class="line"><span>      caches.match(event.request)</span></span>
<span class="line"><span>        .then(function(response) {</span></span>
<span class="line"><span>          // Cache hit - return response</span></span>
<span class="line"><span>          if (response) {</span></span>
<span class="line"><span>            return response;</span></span>
<span class="line"><span>          }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          // IMPORTANT:Clone the request. A request is a stream and</span></span>
<span class="line"><span>          // can only be consumed once. Since we are consuming this</span></span>
<span class="line"><span>          // once by cache and once by the browser for fetch, we need</span></span>
<span class="line"><span>          // to clone the response.</span></span>
<span class="line"><span>          var fetchRequest = event.request.clone();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>          return fetch(fetchRequest).then(</span></span>
<span class="line"><span>            function(response) {</span></span>
<span class="line"><span>              // Check if we received a valid response</span></span>
<span class="line"><span>              if(!response || response.status !== 200 || response.type !== &#39;basic&#39;) {</span></span>
<span class="line"><span>                return response;</span></span>
<span class="line"><span>              }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>              // IMPORTANT:Clone the response. A response is a stream</span></span>
<span class="line"><span>              // and because we want the browser to consume the response</span></span>
<span class="line"><span>              // as well as the cache consuming the response, we need</span></span>
<span class="line"><span>              // to clone it so we have two streams.</span></span>
<span class="line"><span>              var responseToCache = response.clone();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>              caches.open(CACHE_NAME)</span></span>
<span class="line"><span>                .then(function(cache) {</span></span>
<span class="line"><span>                  cache.put(event.request, responseToCache);</span></span>
<span class="line"><span>                });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>              return response;</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>          );</span></span>
<span class="line"><span>        })</span></span>
<span class="line"><span>      );</span></span>
<span class="line"><span>  });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br></div></div><p>执行的操作如下：</p><p>1、在 fetch 请求中添加对 .then() 的回调。 2、获得响应后，执行以下检查：</p><ul><li>确保响应有效。</li><li>检查并确保响应的状态为 200。</li><li>确保响应类型为 basic，亦即由自身发起的请求。 这意味着，对第三方资产的请求也不会添加到缓存。</li></ul><p>3、如果通过检查，则克隆响应。 这样做的原因在于，该响应是数据流， 因此主体只能使用一次。 由于我们想要返回能被浏览器使用的响应，并将其传递到缓存以供使用， 因此需要克隆一份副本。我们将一份发送给浏览器，另一份则保留在缓存。</p><h4 id="更新-service-worker" tabindex="-1">更新 Service Worker <a class="header-anchor" href="#更新-service-worker" aria-label="Permalink to &quot;更新 Service Worker&quot;">​</a></h4><p>在某个时间点，您的 Service Worker 需要更新。 此时，您需要遵循以下步骤：</p><p>1、更新您的服务工作线程 JavaScript 文件。 用户导航至您的站点时，浏览器会尝试在后台重新下载定义 Service Worker 的脚本文件。 如果 Service Worker 文件与其当前所用文件存在字节差异，则将其视为<em>新 Service Worker</em>。</p><p>2、新 Service Worker 将会启动，且将会触发 install 事件。</p><p>3、此时，旧 Service Worker 仍控制着当前页面，因此新 Service Worker 将进入 waiting 状态。</p><p>4、当网站上当前打开的页面关闭时，旧 Service Worker 将会被终止，新 Service Worker 将会取得控制权。</p><p>5、新 Service Worker 取得控制权后，将会触发其 activate 事件。</p>`,61),l=[r];function i(c,o,t,b,u,d){return e(),n("div",null,l)}const h=s(p,[["render",i]]);export{m as __pageData,h as default};
