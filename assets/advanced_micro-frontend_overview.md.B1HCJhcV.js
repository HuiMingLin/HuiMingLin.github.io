import{_ as a,c as i,o as l,a1 as e}from"./chunks/framework.DwaB85k5.js";const b=JSON.parse('{"title":"架构","description":"","frontmatter":{"menu":"微前端"},"headers":[],"relativePath":"advanced/micro-frontend/overview.md","filePath":"advanced/micro-frontend/overview.md","lastUpdated":1720413905000}'),n={name:"advanced/micro-frontend/overview.md"},p=e(`<h1 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h1><p>「技术栈无关」是微前端的核心价值。目标应该是：方案上跟使用 iframe 做微前端一样简单，同时又解决了 iframe 带来的各种体验上的问题。</p><ul><li>应用之间不应该有任何直接或间接的技术栈、依赖、以及实现上的耦合。 <ul><li>比如我们不能要求子应用、主应用必须使用某一版本的技术栈实现。</li><li>比如在通信机制的设计与选择上，尽量基于浏览器原生的 CustomEvent api，而不是自己搞的 pub/sub。</li><li>比如子应用是否具备不依赖宿主环境独立运行的能力，衡量标准是是否能一行代码不改，或者只改很少的配置。</li></ul></li></ul><h2 id="概览" tabindex="-1">概览 <a class="header-anchor" href="#概览" aria-label="Permalink to &quot;概览&quot;">​</a></h2><p>微前端是一种将不同的前端应用组合到一起的架构模式。这些应用可以独立开发、独立部署、独立运行，然后在一个主应用中进行集成。这种模式的主要目标是解决大型、长期演进的前端项目的复杂性问题。</p><p>主要优点：</p><ul><li><p>解耦： 微前端架构可以将大型项目分解为多个可以独立开发、测试和部署的小型应用。这种解耦可以提高开发效率，减少团队间的协调成本。</p></li><li><p>技术栈无关： 不同的微前端应用可以使用不同的技术栈，这为使用新技术、升级旧技术提供了可能。</p></li><li><p>并行开发： 因为微前端应用是独立的，所以多个团队可以并行开发不同的应用，无需担心相互影响。</p></li><li><p>独立部署： 每个微前端应用可以独立部署，这意味着可以更快地推出新功能，同时降低了部署失败的风险。</p></li></ul><p>主要挑战：</p><ul><li><p>性能问题： 如果不同的微前端应用使用了不同的库或框架，可能会导致加载和运行的性能问题。</p></li><li><p>一致性： 保持不同的微前端应用在用户体验、设计和行为上的一致性可能会比较困难。</p></li><li><p>状态共享： 在微前端应用之间共享状态可能会比较复杂，需要使用特殊的工具或模式。</p></li><li><p>复杂性： 尽管微前端可以解决大型项目的复杂性问题，但是它自身也带来了一些复杂性，比如需要管理和协调多个独立的应用。</p></li><li><p>安全性： 微前端架构可能会增加跨域等安全问题。</p></li></ul><p>难点：</p><ul><li><p>预加载</p><p>空闲时加载子应用资源，用户行为数据支持</p></li><li><p>公共依赖加载</p><p>大部分子应用都用到的资源如何处理</p></li><li><p>按需加载</p><p>切换页面时才加载相应的 HTML、CSS 和 JS</p></li><li><p>Config Entry</p><p>配置每个子应用的 JS 和 CSS 包括内联的那些</p></li><li><p>HTML Entry</p><p>Config Entry 的进阶版，简化开发者使用，但把解析消耗留给用户</p></li><li><p>CSS 隔离</p><p>子应用之间样式互不影响，切换时装载和卸载</p></li><li><p>JS 沙箱</p><p>子应用之后互不影响，包括全局变量、事件等处理</p><div><a href="/advanced/micro-frontend/sandbox">JS沙箱</a></div></li><li><p>子应用并行</p><p>多个微前端如何同时存在进阶用法</p></li><li><p>子应用嵌套</p><p>微前端如何嵌套前端进阶用法</p></li><li><p>父子应用通讯</p><p>子应用如何调用父应用方法，父应用如何下发状态</p></li></ul><h2 id="iframe" tabindex="-1">iframe <a class="header-anchor" href="#iframe" aria-label="Permalink to &quot;iframe&quot;">​</a></h2><p>不考虑体验问题，iframe 几乎是最完美的微前端解决方案，最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。</p><p>但他的最大问题也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。</p><ul><li>url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。 <ul><li>比较好解决</li><li>postMessage。</li></ul></li><li>UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中。 <ul><li>无法解决。</li><li>前端：子应用通过 postMessage 调用主应用程序，其他都由主程序实现，后端：消息队列，grpc。</li></ul></li><li>全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果。 <ul><li>很难解决。</li><li>不同域名的 cookie 所携带的内容一致，并且能够确定哪些域名是可以共享 cookie 的。</li></ul></li><li>慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。 <ul><li>睁一只眼闭一只眼。</li><li>prefetch、一旦加载进来就要缓存起来，重复利用。</li></ul></li><li>不能改变其在 DOM 树中的位置，否则会导致重新加载 iframe。</li></ul><h2 id="single-spa" tabindex="-1">single-spa <a class="header-anchor" href="#single-spa" aria-label="Permalink to &quot;single-spa&quot;">​</a></h2><p>single-spa 没有实现 js 沙箱，我们在构建大型微前端应用的时候，很容易造成一些变量的冲突，对应用的可靠性面临巨大的风险。在微前端当中，有一些全局对象在所有的应用中需要共享，如 document,location,等对象。子应用开发的过程中可能是多个团队在做，很难约束他们使用全局变量。有些页面可能会有多个不同的子应用，需要我们支持多沙箱，每个沙箱需要有加载，卸载，在恢复的能力。</p><h2 id="qiankun" tabindex="-1">qiankun <a class="header-anchor" href="#qiankun" aria-label="Permalink to &quot;qiankun&quot;">​</a></h2><p>qiankun 是一个基于 single-spa 的微前端实现框架。</p><p>优点</p><ul><li>降低了应用改造的成本，通过 html entry 的方式引入子应用；</li><li>提供了完备的沙箱方案，包括 js 沙箱和 css 沙箱；</li><li>支持静态资源预加载能力。</li></ul><p>缺点</p><ul><li>适配成本较高，包括工程化、生命周期、静态资源路径、路由等方面的适配；</li><li>css 沙箱的严格隔离可能引发问题，js 沙箱在某些场景下执行性能下降；</li><li>无法同时激活多个子应用，不支持子应用保活；</li><li>不支持 vite 等 esmodule 脚本运行。</li></ul><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><p>应用加载：qiankun 通过动态创建 script 标签的方式加载子应用的入口文件。加载完成后，会执行子应用暴露出的生命周期函数。</p><p>生命周期管理：qiankun 要求每个子应用都需要暴露出 bootstrap、mount 和 unmount 三个生命周期函数。bootstrap 函数在应用加载时被调用，mount 函数在应用启动时被调用，unmount 函数在应用卸载时被调用。</p><p>沙箱隔离：qiankun 通过 Proxy 对象创建了一个 JavaScript 沙箱，用于隔离子应用的全局变量，防止子应用之间的全局变量污染。但是如果我们在子应用中添加了一个全局的点击事件，我们可以在子应用的 unmount 生命周期函数中移除这个事件。</p><p>样式隔离：qiankun 通过动态添加和移除样式标签的方式实现了样式隔离。当子应用启动时，会动态添加子应用的样式标签，当子应用卸载时，会移除子应用的样式标签。</p><p>通信机制：qiankun 提供了一个全局的通信机制，允许子应用之间进行通信。</p><h3 id="加载静态资源" tabindex="-1">加载静态资源 <a class="header-anchor" href="#加载静态资源" aria-label="Permalink to &quot;加载静态资源&quot;">​</a></h3><ul><li><p>使用公共路径 在子应用的静态资源路径前添加公共路径前缀。例如，如果子应用的静态资源存放在 <code>http://localhost:8080/static/</code>，那么可以在所有的静态资源路径前添加这个前缀。</p></li><li><p>劫持标签插入函数</p><p>这个方案分为两步：</p><ul><li><p>对于 HTML 中已有的 img/audio/video 等标签，qiankun 支持重写 getTemplate 函数，可以将入口文件 index.html 中的静态资源路径替换掉。</p></li><li><p>对于动态插入的 img/audio/video 等标签，劫持 appendChild、innerHTML、insertBefore 等事件，将资源的相对路径替换成绝对路径。</p><p>例如，我们可以传递一个 getTemplate 函数，将图片的相对路径转为绝对路径，它会在处理模板时使用：</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>start({</span></span>
<span class="line"><span>  getTemplate(tpl,...rest) {</span></span>
<span class="line"><span>    // 为了直接看到效果，所以写死了，实际中需要用正则匹配</span></span>
<span class="line"><span>    return tpl.replace(&#39;&lt;img src=&quot;./img/jQuery1.png&quot;&gt;&#39;, &#39;&lt;img src=&quot;http://localhost:3333/img/jQuery1.png&quot;&gt;&#39;);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>对于动态插入的标签，劫持其插入 DOM 的函数，注入前缀。</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>beforeMount: app =&gt; {</span></span>
<span class="line"><span>  if(app.name === &#39;purehtml&#39;){</span></span>
<span class="line"><span>      // jQuery 的 html 方法是一个挺复杂的函数，这里只是为了看效果，简写了</span></span>
<span class="line"><span>      $.prototype.html = function(value){</span></span>
<span class="line"><span>          const str = value.replace(&#39;&lt;img src=&quot;/img/jQuery2.png&quot;&gt;&#39;, &#39;&lt;img src=&quot;http://localhost:3333/img/jQuery2.png&quot;&gt;&#39;)</span></span>
<span class="line"><span>          this[0].innerHTML = str;</span></span>
<span class="line"><span>      }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li></ul></li><li><p>项目加上 webpack 打包</p></li></ul><h3 id="资源加载机制" tabindex="-1">资源加载机制 <a class="header-anchor" href="#资源加载机制" aria-label="Permalink to &quot;资源加载机制&quot;">​</a></h3><p>qiankun import-html-entry 是 qiankun 框架中用于加载子应用的 HTML 入口文件的工具函数。它提供了一种方便的方式来动态加载和解析子应用的 HTML 入口文件，并返回一个可以加载子应用的 JavaScript 模块。</p><p>具体而言，import-html-entry 实现了以下功能：</p><ul><li><p>加载 HTML 入口文件：import-html-entry 会通过创建一个 <code>&lt;link&gt;</code> 标签来加载子应用的 HTML 入口文件。这样可以确保子应用的资源得到正确加载，并在加载完成后进行处理。</p></li><li><p>解析 HTML 入口文件：一旦 HTML 入口文件加载完成，import-html-entry 将解析该文件的内容，提取出子应用的 JavaScript 和 CSS 资源的 URL。</p></li><li><p>动态加载 JavaScript 和 CSS 资源：import-html-entry 使用动态创建 script 和 link 标签的方式，按照正确的顺序加载子应用的 JavaScript 和 CSS 资源。</p></li><li><p>创建沙箱环境：在加载子应用的 JavaScript 资源时，import-html-entry 会创建一个沙箱环境（sandbox），用于隔离子应用的全局变量和运行环境，防止子应用之间的冲突和污染。</p></li><li><p>返回子应用的入口模块：最后，import-html-entry 返回一个可以加载子应用的 JavaScript 模块。这个模块通常是一个包含子应用初始化代码的函数，可以在主应用中调用以加载和启动子应用。</p></li></ul><p>通过使用 qiankun import-html-entry，开发者可以方便地将子应用的 HTML 入口文件作为模块加载，并获得一个可以加载和启动子应用的函数，简化了子应用的加载和集成过程。</p><h3 id="start-函数" tabindex="-1">start 函数 <a class="header-anchor" href="#start-函数" aria-label="Permalink to &quot;start 函数&quot;">​</a></h3><p>start 函数接收一个可选的配置对象作为参数，这个对象可以包含以下属性：</p><p>prefetch：预加载模式，可选值有 true、false、&#39;all&#39;、&#39;popstate&#39;。默认值为 true，即在主应用 start 之后即刻开始预加载所有子应用的静态资源。如果设置为 &#39;all&#39;，则主应用 start 之后会预加载所有子应用静态资源，无论子应用是否激活。如果设置为 &#39;popstate&#39;，则只有在路由切换的时候才会去预加载对应子应用的静态资源。</p><p>sandbox：沙箱模式，可选值有 true、false、{ strictStyleIsolation: true }。默认值为 true，即为每个子应用创建一个新的沙箱环境。如果设置为 false，则子应用运行在当前环境下，没有任何的隔离。如果设置为 { strictStyleIsolation: true }，则会启用严格的样式隔离模式，即子应用的样式会被完全隔离，不会影响到其他子应用和主应用。</p><p>singular：是否为单例模式，可选值有 true、false。默认值为 true，即一次只能有一个子应用处于激活状态。如果设置为 false，则可以同时激活多个子应用。</p><p>fetch：自定义的 fetch 方法，用于加载子应用的静态资源。</p><p>如果只有一个子项目，要想启用预加载，可以这样使用 start 函数：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">start</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({ prefetch: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;all&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这样，主应用 start 之后会预加载子应用的所有静态资源，无论子应用是否激活。</p><h3 id="源码" tabindex="-1">源码 <a class="header-anchor" href="#源码" aria-label="Permalink to &quot;源码&quot;">​</a></h3><div><a href="/advanced/micro-frontend/qiankun/sandbox">JS沙箱</a></div><div><a href="/advanced/micro-frontend/qiankun/import-html-entry">import-html-entry</a></div><h2 id="micro-app-方案" tabindex="-1">micro-app 方案 <a class="header-anchor" href="#micro-app-方案" aria-label="Permalink to &quot;micro-app 方案&quot;">​</a></h2><p>优点</p><ul><li>使用 webcomponent 加载子应用，更优雅；</li><li>复用经过大量项目验证过的 qiankun 沙箱机制，提高了框架的可靠性；</li><li>支持子应用保活；</li><li>降低了子应用改造的成本，提供了静态资源预加载能力。</li></ul><p>缺点</p><ul><li>接入成本虽然降低，但路由依然存在依赖；</li><li>多应用激活后无法保持各子应用的路由状态，刷新后全部丢失；</li><li>css 沙箱无法完全隔离，js 沙箱做全局变量查找缓存，性能有所优化；</li><li>支持 vite 运行，但必须使用 plugin 改造子应用，且 js 代码没办法做沙箱隔离；</li><li>对于不支持 webcomponent 的浏览器没有做降级处理。</li></ul><h2 id="emp-方案" tabindex="-1">EMP 方案 <a class="header-anchor" href="#emp-方案" aria-label="Permalink to &quot;EMP 方案&quot;">​</a></h2><p>优点</p><ul><li>webpack 联邦编译可以保证所有子应用依赖解耦；</li><li>支持应用间去中心化的调用、共享模块；</li><li>支持模块远程 ts 支持。</li></ul><p>缺点</p><ul><li>对 webpack 强依赖，对于老旧项目不友好；</li><li>没有有效的 css 沙箱和 js 沙箱，需要靠用户自觉；</li><li>子应用保活、多应用激活无法实现；</li><li>主、子应用的路由可能发生冲突。</li></ul><h2 id="无界方案" tabindex="-1">无界方案 <a class="header-anchor" href="#无界方案" aria-label="Permalink to &quot;无界方案&quot;">​</a></h2><p>优点</p><p>基于 webcomponent 容器和 iframe 沙箱，充分解决了适配成本、样式隔离、运行性能、页面白屏、子应用通信、子应用保活、多应用激活、vite 框架支持、应用共享等问题。 缺点</p><p>在继承了 iframe 优点的同时，缺点依旧还是存在，因为它使得主应用和子应用之间的通信变得困难。此外，iframe 还有一些其他的问题，比如性能问题、SEO 问题等。</p><h2 id="微服务" tabindex="-1">微服务 <a class="header-anchor" href="#微服务" aria-label="Permalink to &quot;微服务&quot;">​</a></h2><h3 id="hapi" tabindex="-1">Hapi <a class="header-anchor" href="#hapi" aria-label="Permalink to &quot;Hapi&quot;">​</a></h3><h3 id="restfy" tabindex="-1">Restfy <a class="header-anchor" href="#restfy" aria-label="Permalink to &quot;Restfy&quot;">​</a></h3><h2 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h2><div><a href="/advanced/micro-frontend/example/vite_qiankun">vite + qiankun</a></div>`,67),s=[p];function t(r,o,u,c,h,d){return l(),i("div",null,s)}const f=a(n,[["render",t]]);export{b as __pageData,f as default};
