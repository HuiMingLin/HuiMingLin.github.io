import{_ as a,c as s,o as n,a1 as e}from"./chunks/framework.DwaB85k5.js";const h=JSON.parse('{"title":"npm","description":"","frontmatter":{},"headers":[],"relativePath":"basic/package-manager/npm.md","filePath":"basic/package-manager/npm.md","lastUpdated":1720071416000}'),p={name:"basic/package-manager/npm.md"},l=e(`<h1 id="npm" tabindex="-1">npm <a class="header-anchor" href="#npm" aria-label="Permalink to &quot;npm&quot;">​</a></h1><h2 id="node-modules-结构" tabindex="-1">node_modules 结构 <a class="header-anchor" href="#node-modules-结构" aria-label="Permalink to &quot;node_modules 结构&quot;">​</a></h2><h3 id="v3-之前" tabindex="-1">v3 之前 <a class="header-anchor" href="#v3-之前" aria-label="Permalink to &quot;v3 之前&quot;">​</a></h3><p>node_modules 中的每个依赖项都有自己的 node_modules 文件夹，其所有依赖项都在 package.json 中指定。</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>└─ foo</span></span>
<span class="line"><span>   ├─ index.js</span></span>
<span class="line"><span>   ├─ package.json</span></span>
<span class="line"><span>   └─ node_modules</span></span>
<span class="line"><span>      └─ bar</span></span>
<span class="line"><span>         ├─ index.js</span></span>
<span class="line"><span>         └─ package.json</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>软件包经常创建过深的依赖树，导致 Windows 上出现目录路径过长的问题。</li><li>在不同的依赖关系中需要使用软件包时，却将它们复制粘贴了多次。</li></ul><h3 id="v3-之后" tabindex="-1">v3 之后 <a class="header-anchor" href="#v3-之后" aria-label="Permalink to &quot;v3 之后&quot;">​</a></h3><p>扁平化 node_modules 结构</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>├─ foo</span></span>
<span class="line"><span>|  ├─ index.js</span></span>
<span class="line"><span>|  └─ package.json</span></span>
<span class="line"><span>└─ bar</span></span>
<span class="line"><span>   ├─ index.js</span></span>
<span class="line"><span>   └─ package.json</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li>模块可以访问它们不依赖的软件包。</li><li>扁平化依赖树的算法相当复杂。</li><li>某些软件包必须复制到一个项目的 node_modules 文件夹中。</li></ul>`,12),i=[l];function r(o,t,c,d,m,u){return n(),s("div",null,i)}const _=a(p,[["render",r]]);export{h as __pageData,_ as default};
