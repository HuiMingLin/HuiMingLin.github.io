import{_ as e,c as i,o as t,a1 as l}from"./chunks/framework.DwaB85k5.js";const s="/assets/image-1.CHSPPR0d.png",a="/assets/image-2.D3h2E3Af.png",p="/assets/image-3.DlMuFSML.png",r="/assets/image-4.DqNr02a2.png",n="/assets/image-5.FRaAcgSY.png",d="/assets/image-6.Cw9fm5er.png",V=JSON.parse('{"title":"性能利器——Esbuild","description":"","frontmatter":{},"headers":[],"relativePath":"domain/engineering/build/vite/dual-engine-architecture/esbuild/index.md","filePath":"domain/engineering/build/vite/dual-engine-architecture/esbuild/index.md","lastUpdated":1720962985000}'),u={name:"domain/engineering/build/vite/dual-engine-architecture/esbuild/index.md"},o=l('<h1 id="性能利器——esbuild" tabindex="-1">性能利器——Esbuild <a class="header-anchor" href="#性能利器——esbuild" aria-label="Permalink to &quot;性能利器——Esbuild&quot;">​</a></h1><p>必须要承认的是，Esbuild 的确是 Vite 高性能的得力助手，在很多关键的构建阶段让 Vite 获得了相当优异的性能，如果这些阶段用传统的打包器/编译器来完成的话，开发体验要下降一大截。</p><p>那么，Esbuild 到底在 Vite 的构建体系中发挥了哪些作用？</p><h2 id="依赖预构建——作为-bundle-工具" tabindex="-1">依赖预构建——作为 Bundle 工具 <a class="header-anchor" href="#依赖预构建——作为-bundle-工具" aria-label="Permalink to &quot;依赖预构建——作为 Bundle 工具&quot;">​</a></h2><p>首先是开发阶段的依赖预构建阶段。</p><p><img src="'+s+'" alt="alt text"></p><p>一般来说，node_modules 依赖的大小动辄几百 MB 甚至上 GB ，会远超项目源代码，相信大家都深有体会。如果这些依赖直接在 Vite 中使用，会出现一系列的问题，这些问题我们在依赖预构建的小节已经详细分析过，主要是 ESM 格式的兼容性问题和海量请求的问题，不再赘述。总而言之，对于第三方依赖，需要在应用启动前进行打包并且转换为 ESM 格式。</p><p>Vite 1.x 版本中使用 Rollup 来做这件事情，但 Esbuild 的性能实在是太恐怖了，Vite 2.x 果断采用 Esbuild 来完成第三方依赖的预构建，至于性能到底有多强，大家可以参照它与传统打包工具的性能对比图:</p><p><img src="'+a+'" alt="alt text"></p><p>当然，Esbuild 作为打包工具也有一些缺点。</p><ul><li>不支持降级到 ES5 的代码。这意味着在低端浏览器代码会跑不起来。</li><li>不支持 const enum 等语法。这意味着单独使用这些语法在 esbuild 中会直接抛错。</li><li>不提供操作打包产物的接口，像 Rollup 中灵活处理打包产物的能力(如 renderChunk 钩子)在 Esbuild 当中完全没有。</li><li>不支持自定义 Code Splitting 策略。传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 Esbuild 并未提供，从而降级了拆包优化的灵活性。</li></ul><p>尽管 Esbuild 作为一个社区新兴的明星项目，有如此多的局限性，但依然不妨碍 Vite 在开发阶段使用它成功启动项目并获得极致的性能提升，生产环境处于稳定性考虑当然是采用功能更加丰富、生态更加成熟的 Rollup 作为依赖打包工具了。</p><h2 id="单文件编译——作为-ts-和-jsx-编译工具" tabindex="-1">单文件编译——作为 TS 和 JSX 编译工具 <a class="header-anchor" href="#单文件编译——作为-ts-和-jsx-编译工具" aria-label="Permalink to &quot;单文件编译——作为 TS 和 JSX 编译工具&quot;">​</a></h2><p>在依赖预构建阶段， Esbuild 作为 Bundler 的角色存在。而在 TS(X)/JS(X) 单文件编译上面，Vite 也使用 Esbuild 进行语法转译，也就是将 Esbuild 作为 Transformer 来用。大家可以在架构图中 Vite Plugin Pipeline 部分注意到:</p><p><img src="'+p+'" alt="alt text"></p><p>也就是说，Esbuild 转译 TS 或者 JSX 的能力通过 Vite 插件提供，这个 Vite 插件在开发环境和生产环境都会执行，因此，我们可以得出下面这个结论:</p><blockquote><p>Vite 已经将 Esbuild 的 Transformer 能力用到了生产环境。尽管如此，对于低端浏览器场景，Vite 仍然可以做到语法和 Polyfill 安全。</p></blockquote><p>这部分能力用来替换原先 Babel 或者 TSC 的功能，因为无论是 Babel 还是 TSC 都有性能问题，大家对这两个工具普遍的认知都是: 慢，太慢了。</p><p>当 Vite 使用 Esbuild 做单文件编译之后，提升可以说相当大了，我们以一个巨大的、50 多 MB 的纯代码文件为例，来对比 Esbuild、Babel、TSC 包括 SWC 的编译性能:</p><p><img src="'+r+'" alt="alt text"></p><p>虽然 Esbuild Transfomer 能带来巨大的性能提升，但其自身也有局限性，最大的局限性就在于 TS 中的类型检查问题。这是因为 Esbuild 并没有实现 TS 的类型系统，在编译 TS(或者 TSX) 文件时仅仅抹掉了类型相关的代码，暂时没有能力实现类型检查。</p><p>也因此，快速上手这一节，我让大家注意初始化工程的构建脚本，vite build 之前会先执行 tsc 命令，也就是借助 TS 官方的编译器进行类型检查。</p><p>当然，要解决类型问题，我更推荐大家使用 TS 的编辑器插件。在开发阶段就能早早把问题暴露出来并解决，不至于等到项目要打包上线的时候。</p><h2 id="代码压缩——作为压缩工具" tabindex="-1">代码压缩——作为压缩工具 <a class="header-anchor" href="#代码压缩——作为压缩工具" aria-label="Permalink to &quot;代码压缩——作为压缩工具&quot;">​</a></h2><blockquote><p>Vite 从 2.6 版本开始，就官宣默认使用 Esbuild 来进行生产环境的代码压缩，包括 JS 代码和 CSS 代码。</p></blockquote><p>从架构图中可以看到，在生产环境中 Esbuild 压缩器通过插件的形式融入到了 Rollup 的打包流程中:</p><p><img src="'+n+'" alt="alt text"></p><p>那为什么 Vite 要将 Esbuild 作为生产环境下默认的压缩工具呢？因为压缩效率实在太高了！</p><p>传统的方式都是使用 Terser 这种 JS 开发的压缩器来实现，在 Webpack 或者 Rollup 中作为一个 Plugin 来完成代码打包后的压缩混淆的工作。但 Terser 其实很慢，主要有 2 个原因。</p><ul><li>压缩这项工作涉及大量 AST 操作，并且在传统的构建流程中，AST 在各个工具之间无法共享，比如 Terser 就无法与 Babel 共享同一个 AST，造成了很多重复解析的过程。</li><li>JS 本身属于解释性 + JIT（即时编译） 的语言，对于压缩这种 CPU 密集型的工作，其性能远远比不上 Golang 这种原生语言。</li></ul><p>因此，Esbuild 这种从头到尾共享 AST 以及原生语言编写的 Minifier 在性能上能够甩开传统工具的好几十倍。</p><p>举个例子，我们可以看下面这个实际大型库(echarts)的压缩性能测试项目:</p><p><img src="'+d+'" alt="alt text"></p><p>压缩一个大小为 3.2 MB 的库，Terser 需要耗费 8798 ms，而 Esbuild 仅仅需要 361 ms，压缩效率较 Terser 提升了二三十倍，并且产物的体积几乎没有劣化，因此 Vite 果断将其内置为默认的压缩方案。</p><p>总的来说，Vite 将 Esbuild 作为自己的性能利器，将 Esbuild 各个垂直方向的能力(Bundler、Transformer、Minifier)利用的淋漓尽致，给 Vite 的高性能提供了有利的保证。</p>',35),b=[o];function c(m,_,S,g,E,T){return t(),i("div",null,b)}const f=e(u,[["render",c]]);export{V as __pageData,f as default};
