import{_ as a,c as e,o as i,a1 as l}from"./chunks/framework.DwaB85k5.js";const m=JSON.parse('{"title":"垃圾回收机制","description":"","frontmatter":{"menu":"linux"},"headers":[],"relativePath":"advanced/browser/engine/engine.md","filePath":"advanced/browser/engine/engine.md","lastUpdated":1717275443000}'),r={name:"advanced/browser/engine/engine.md"},t=l('<p>V8 是一种开源的JavaScript 引擎，它主要用于Chrome 浏览器和Node.js 环境。</p><h1 id="垃圾回收机制" tabindex="-1">垃圾回收机制 <a class="header-anchor" href="#垃圾回收机制" aria-label="Permalink to &quot;垃圾回收机制&quot;">​</a></h1><p>V8 引擎中的垃圾回收机制负责自动管理内存的分配和释放，以确保程序运行期间不会出现内存泄漏或垃圾堆积的问题。</p><p>V8 引擎的垃圾回收机制基于 <strong>代际假说</strong> 和 <strong>分代回收</strong> 的原理。它将内存分为**新生代（young generation）<strong>和</strong>老生代（old generation）**两个代。新生代用于存放新创建的对象，老生代用于存放经过一定时间仍然存活的对象。</p><h2 id="一般流程" tabindex="-1">一般流程 <a class="header-anchor" href="#一般流程" aria-label="Permalink to &quot;一般流程&quot;">​</a></h2><ul><li><p>新生代垃圾回收：V8 将新生代内存空间分为两个部分：From 空间和 To 空间。新创建的对象首先被分配到From 空间，当From 空间满时，会触发垃圾回收过程。回收过程中，V8 首先进行标记操作，标记活跃的对象，然后将这些对象复制到 To 空间，同时进行压缩等操作。最后，From 空间和 To 空间的角色互换，完成垃圾回收。</p></li><li><p>老生代垃圾回收：老生代中的对象由于存活时间较长，垃圾回收的成本较高。V8 使用标记-清除（mark-sweep）和标记-压缩（mark-compact）两种算法进行老生代的垃圾回收。标记-清除算法首先进行标记操作，标记出活跃的对象，然后清除未标记的对象。标记-压缩算法在清除未标记的对象后，将存活的对象压缩到内存的一端，从而减少内存碎片化。</p></li><li><p>增量标记：为了降低垃圾回收对程序执行的影响，V8 引擎使用增量标记算法。增量标记允许垃圾回收过程与程序执行交替进行，每次执行一小部分的标记操作，减少了垃圾回收对程序的中断时间。</p></li></ul><p>V8 引擎的垃圾回收机制是自动进行的，开发者无需手动管理内存。但是，了解垃圾回收机制的工作原理有助于编写高效的JavaScript 代码，避免内存泄漏和性能问题。</p><h2 id="策略" tabindex="-1">策略 <a class="header-anchor" href="#策略" aria-label="Permalink to &quot;策略&quot;">​</a></h2><h3 id="标记清除" tabindex="-1">标记清除 <a class="header-anchor" href="#标记清除" aria-label="Permalink to &quot;标记清除&quot;">​</a></h3><p>标记清除（ Mark-Sweep ），目前在 JavaScript引擎 里这种算法是最常用的，到目前为止的大多数浏览器的 JavaScript引擎 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 JavaScript引擎 在运行垃圾回收的频率上有所差异。此算法分为 标记 和 清除 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。</p><p>引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组根对象，而所谓的根对象，其实在浏览器环境中包括又不止于 全局Window对象、文档DOM树等。</p><p>整个标记清除算法大致过程就像下面这样：</p><ul><li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0；</li><li>然后从各个根对象开始遍历，把不是垃圾的节点改成1；</li><li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间；</li><li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收；</li></ul><p>优点：</p><p>实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单</p><p>缺点：</p><p>在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片，并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题</p><h3 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h3><p>引用计数（ Reference Counting ），这其实是早先的一种垃圾回收算法，它把对象是否不再需要简化定义为对象有没有其他对象引用到它，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，但因为它的问题很多，目前很少使用这种算法了。</p><p>它的策略是跟踪记录每个变量值被使用的次数</p><ul><li>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1；</li><li>如果同一个值又被赋给另一个变量，那么引用数加 1；</li><li>如果该变量的值被其他的值覆盖了，则引用次数减 1；</li><li>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存；</li></ul><p>优点：</p><ul><li>引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾；</li><li>标记清除算法需要每隔一段时间进行一次，那在应用程序（JS脚本）运行过程中线程就必须要暂停去执行一段时间的 GC，另外，标记清除算法需要遍历堆里的活动以及非活动对象来清除，而引用计数则只需要在引用时计数就可以了；</li></ul><p>缺点：</p><ul><li>需要一个计数器，而此计数器需要占很大的位置，因为我们也不知道被引用数量的上限；</li><li>无法解决循环引用无法回收的问题；</li></ul>',25),n=[t];function o(p,s,c,d,h,u){return i(),e("div",null,n)}const g=a(r,[["render",o]]);export{m as __pageData,g as default};
