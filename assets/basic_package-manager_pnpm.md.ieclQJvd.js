import{_ as s,c as n,o as a,a1 as p}from"./chunks/framework.DwaB85k5.js";const e="/assets/soft-hard-link.CNqZUi1s.png",g=JSON.parse('{"title":"pnpm","description":"","frontmatter":{},"headers":[],"relativePath":"basic/package-manager/pnpm.md","filePath":"basic/package-manager/pnpm.md","lastUpdated":1720432640000}'),l={name:"basic/package-manager/pnpm.md"},i=p(`<h1 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;pnpm&quot;">​</a></h1><p>pnpm 是 Node.js 的替代软件包管理器。它是 npm 的直接替代品，但速度更快，效率更高。</p><p>为什么效率更高？当你安装一个软件包时，我们会将其保存在你机器上的全局存储中，通过<strong>硬链接</strong>连接文件存储位置，然后创建一个<strong>软链接</strong>连接某个文件或目录，而不是复制。</p><p>例如，使用 npm 或 yarn 时，如果有 100 个软件包使用 lodash，那么磁盘上就会有 100 份 lodash 的副本。Pnpm 可以节省数千兆字节的磁盘空间！</p><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> i</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -g</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pnpm</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>由于默认的镜像源在国外，包下载速度和稳定性都不太好，因此我建议你换成国内的镜像源，这样 pnpm install 命令的体验会好很多，命令如下:</p><div class="language-shell vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> registry</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://registry.npmmirror.com/</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="inode" tabindex="-1">inode <a class="header-anchor" href="#inode" aria-label="Permalink to &quot;inode&quot;">​</a></h2><p>文件在计算机的存储形式：每个文件都独自占用一个 inode，文件内容由 inode 的记录来文件的权限（r、w、x）、文件的所有者和属组、文件的大小、文件的状态改变时间（ctime）、文件的最近一次读取时间（atime）、文件的最近一次修改时间（mtime）、文件的数据真正保存的 block 编号，</p><p>想要读取文件内容，就必须借助目录中记录的文件名找到该文件的 inode，才能成功找到文件内容所在的 block 块。</p><h2 id="硬链接" tabindex="-1">硬链接 <a class="header-anchor" href="#硬链接" aria-label="Permalink to &quot;硬链接&quot;">​</a></h2><p>hard link 是电脑文件系统中的多个文件平等地共享同一个文件存储单元。</p><ul><li>多个文件可以指向源文件同一 inode。</li><li>删除其中一个文件不影响对另一个文件的访问，文件内容的修改会同步到所有文件。</li><li>只能给文件创建硬链接，不能给目录创建。</li><li>适用场景：用于镜像数据文件，防止误删。</li></ul><h2 id="符号链接" tabindex="-1">符号链接 <a class="header-anchor" href="#符号链接" aria-label="Permalink to &quot;符号链接&quot;">​</a></h2><p>软链接、Symbolic link 是一类特殊的文件；（可以理解成快捷方式）。</p><p>其包含有一条以绝对路径或者相对路径的形式指向其它文件或者目录的引用。</p><ul><li>软链接是一个链接文件，指向源文件的地址。类似索引或者指针。</li><li>修改源文件内容，软链接内容也会改变。当删除源文件时，访问软链接会报错 No such file or directory。删除软连接源文件依旧能访问。</li></ul><h2 id="软硬链接区别" tabindex="-1">软硬链接区别 <a class="header-anchor" href="#软硬链接区别" aria-label="Permalink to &quot;软硬链接区别&quot;">​</a></h2><table><thead><tr><th></th><th>软连接</th><th>硬链接</th></tr></thead><tbody><tr><td>inode</td><td>软链接与源文件拥有不同的 inode，是两个不同的文件</td><td>硬链接和源文件拥有同一个 inode，它们其实互为硬链接</td></tr><tr><td>文件属性</td><td>链接文件</td><td>与源文件类型相同</td></tr><tr><td>跨文件系统建立</td><td>支持</td><td>不支持</td></tr><tr><td>链接数目（也就是文件信息中的 nlink）</td><td>nlink 不会随着软链接数目增加</td><td>每增加一个两链接 nlink 也会加 1</td></tr><tr><td>删除源文件</td><td>软链接无法正常访问</td><td>硬链接文件可正常访问</td></tr><tr><td>应用</td><td>1. pnpm 中解决幻影依赖的场景\`\`2. 快捷方式（windows 中创建桌面快捷方式）</td><td>文件备份防误删</td></tr></tbody></table><h2 id="node-modules-结构" tabindex="-1">node_modules 结构 <a class="header-anchor" href="#node-modules-结构" aria-label="Permalink to &quot;node_modules 结构&quot;">​</a></h2><p><code>-&gt;</code> 表示<strong>符号链接</strong></p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>└── .pnpm</span></span>
<span class="line"><span>    ├── foo@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── foo  硬链接</span></span>
<span class="line"><span>    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux</span></span>
<span class="line"><span>    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh</span></span>
<span class="line"><span>    ├── qux@1.0.0</span></span>
<span class="line"><span>    ├── plugh@1.0.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><img src="`+e+`" alt="软硬链接原理图"></p><h3 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h3><p><a href="https://pnpm.io/zh/blog/2020/05/27/flat-node-modules-is-not-the-only-way" target="_blank" rel="noreferrer">Pnpm 官方例子</a></p><p>如果有 peer dependencies</p><p>如果 foo 有<strong>对等依赖</strong>关系，则可能有多组依赖关系，因此我们要为不同的对等依赖关系解决方案创建不同的依赖关系集：</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>└── .pnpm</span></span>
<span class="line"><span>    ├── foo@1.0.0_bar@1.0.0+baz@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── foo</span></span>
<span class="line"><span>    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar</span></span>
<span class="line"><span>    │       ├── **baz**   -&gt; ../../baz@1.0.0/node_modules/baz</span></span>
<span class="line"><span>    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux</span></span>
<span class="line"><span>    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh</span></span>
<span class="line"><span>    ├── foo@1.0.0_bar@1.0.0+baz@1.1.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── foo</span></span>
<span class="line"><span>    │       ├── bar   -&gt; ../../bar@1.0.0/node_modules/bar</span></span>
<span class="line"><span>    │       ├── **baz**   -&gt; ../../baz@1.1.0/node_modules/baz</span></span>
<span class="line"><span>    │       ├── qux   -&gt; ../../qux@1.0.0/node_modules/qux</span></span>
<span class="line"><span>    │       └── plugh -&gt; ../../plugh@1.0.0/node_modules/plugh</span></span>
<span class="line"><span>    ├── bar@1.0.0</span></span>
<span class="line"><span>    ├── baz@1.0.0</span></span>
<span class="line"><span>    ├── baz@1.1.0</span></span>
<span class="line"><span>    ├── qux@1.0.0</span></span>
<span class="line"><span>    ├── plugh@1.0.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><p>没有对等依赖关系，但与图中更高一级的同级软件包有依赖关系，那么该传递软件包就会以不同的依赖关系集出现在项目中。</p><p>例如，有一个包a@1.0.0只有一个依赖关系 b@1.0.0。b@1.0.0 有一个对等依赖关系 c@^1。a@1.0.0 将永远不会解析 b@1.0.0 的对等对象，因此它也变得依赖于 b@1.0.0 的对等对象。</p><p>在这个示例中，a@1.0.0 需要在项目的 node_modules 中出现两次，一次与 c@1.0.0 解析，另一次与 c@1.1.0 解析。</p><div class="language-txt vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>node_modules</span></span>
<span class="line"><span>└── .pnpm</span></span>
<span class="line"><span>    ├── a@1.0.0_c@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── a</span></span>
<span class="line"><span>    │       └── b -&gt; ../../b@1.0.0_c@1.0.0/node_modules/b</span></span>
<span class="line"><span>    ├── a@1.0.0_c@1.1.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── a</span></span>
<span class="line"><span>    │       └── b -&gt; ../../b@1.0.0_c@1.1.0/node_modules/b</span></span>
<span class="line"><span>    ├── b@1.0.0_c@1.0.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── b</span></span>
<span class="line"><span>    │       └── c -&gt; ../../c@1.0.0/node_modules/c</span></span>
<span class="line"><span>    ├── b@1.0.0_c@1.1.0</span></span>
<span class="line"><span>    │   └── node_modules</span></span>
<span class="line"><span>    │       ├── b</span></span>
<span class="line"><span>    │       └── c -&gt; ../../c@1.1.0/node_modules/c</span></span>
<span class="line"><span>    ├── c@1.0.0</span></span>
<span class="line"><span>    ├── c@1.1.0</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h2 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h2><ul><li>security：安全性与 Yarn 一样，pnpm 也有一个包含所有<strong>已安装软件包校验和</strong>的特殊文件，以便在执行代码前验证每个已安装软件包的完整性。</li><li>offline mode：pnpm 会将所有下载的软件包压缩包保存在<strong>本地注册镜像</strong>中。使用 --offline 参数，可以完全禁止 HTTP 请求。</li><li>speed：pnpm 不仅比 npm 快，还比 Yarn 快。无论是使用冷缓存还是热缓存，它都比 Yarn 快。Yarn 从缓存中复制文件，而 pnpm 只是从<strong>全局</strong>存储中<strong>链接文件</strong>。</li></ul>`,35),r=[i];function t(d,o,c,b,u,m){return a(),n("div",null,r)}const k=s(l,[["render",t]]);export{g as __pageData,k as default};
