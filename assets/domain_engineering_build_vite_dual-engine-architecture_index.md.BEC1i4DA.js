import{_ as e,c as t,o as a,a1 as i}from"./chunks/framework.DwaB85k5.js";const l="/assets/image.Bn9fUBXf.png",r="/assets/image-1.BrtayJQo.png",n="/assets/image-2.CtANv3tA.png",f=JSON.parse('{"title":"双引擎架构","description":"","frontmatter":{},"headers":[],"relativePath":"domain/engineering/build/vite/dual-engine-architecture/index.md","filePath":"domain/engineering/build/vite/dual-engine-architecture/index.md","lastUpdated":1721117356000}'),o={name:"domain/engineering/build/vite/dual-engine-architecture/index.md"},p=i('<h1 id="双引擎架构" tabindex="-1">双引擎架构 <a class="header-anchor" href="#双引擎架构" aria-label="Permalink to &quot;双引擎架构&quot;">​</a></h1><h2 id="vite-架构图" tabindex="-1">Vite 架构图 <a class="header-anchor" href="#vite-架构图" aria-label="Permalink to &quot;Vite 架构图&quot;">​</a></h2><p>很多人对 Vite 的双引擎架构仅仅停留在开发阶段使用 Esbuild，生产环境用 Rollup 的阶段，殊不知，Vite 真正的架构远没有这么简单。一图胜千言，这里放一张 Vite 架构图：</p><p><img src="'+l+'" alt="alt text"></p><p>相信对于 Vite 的双引擎架构，你可以从图中略窥一二。在接下来的内容中，我会围绕这张架构图展开双引擎的介绍，到时候你会对这份架构图理解得更透彻。</p><h2 id="性能利器——esbuild" tabindex="-1">性能利器——Esbuild <a class="header-anchor" href="#性能利器——esbuild" aria-label="Permalink to &quot;性能利器——Esbuild&quot;">​</a></h2><div><a href="/domain/engineering/build/vite/dual-engine-architecture/esbuild/index">Esbuild</a></div><h2 id="构建基石——rollup" tabindex="-1">构建基石——Rollup <a class="header-anchor" href="#构建基石——rollup" aria-label="Permalink to &quot;构建基石——Rollup&quot;">​</a></h2><div><a href="/domain/engineering/build/vite/dual-engine-architecture/rollup/index">Rollup</a></div><h2 id="兼容插件机制" tabindex="-1">兼容插件机制 <a class="header-anchor" href="#兼容插件机制" aria-label="Permalink to &quot;兼容插件机制&quot;">​</a></h2><p>无论是开发阶段还是生产环境，Vite 都根植于 Rollup 的插件机制和生态，如下面的架构图所示:</p><p><img src="'+r+'" alt="alt text"></p><p>在开发阶段，Vite 借鉴了 <a href="https://github.com/preactjs/wmr" target="_blank" rel="noreferrer">WMR</a> 的思路，自己实现了一个 Plugin Container，用来模拟 Rollup 调度各个 Vite 插件的执行逻辑，而 Vite 的插件写法完全兼容 Rollup，因此在生产环境中将所有的 Vite 插件传入 Rollup 也没有问题。</p><p>反过来说，Rollup 插件却不一定能完全兼容 Vite(这部分我们会在插件开发小节展开来说)。不过，目前仍然有不少 Rollup 插件可以直接复用到 Vite 中，你可以通过这个站点查看所有兼容 Vite 的 Rollup 插件: <a href="https://vite-rollup-plugins.patak.dev/" target="_blank" rel="noreferrer">https://vite-rollup-plugins.patak.dev/</a> 。</p><p><img src="'+n+'" alt="alt text"></p><p>狼叔在<a href="https://mp.weixin.qq.com/s/mt2Uyh-lpHqHAHqjsen7zw" target="_blank" rel="noreferrer">《以框架定位论前端的先进性》</a> 提到现代前端框架的几大分类，Vite 属于人有我优的类型，因为类似的工具之前有 Snowpack，Vite 诞生之后补齐了作为一个 no-bundle 构建工具的 Dev Server 能力(如 HMR)，确实比现有的工具能力更优。但更重要的是，Vite 在社区生态方面比 Snowpack 更占先天优势。</p><p>Snowpack 自研了一套插件机制，类似 Rollup 的 Hook 机制，可以看出借鉴了 Rollup 的插件机制，但并不能兼容任何现有的打包工具。如果需要打包，只能调用其它打包工具的 API，自身不提供打包能力。</p><p>而 Vite 的做法是从头到尾根植于的 Rollup 的生态，设计了和 Rollup 非常吻合的插件机制，而 Rollup 作为一个非常成熟的打包方案，从诞生至今已经迭代了六年多的时间，npm 年下载量达到上亿次，产物质量和稳定性都经历过大规模的验证。某种程度上说，这种根植于已有成熟工具的思路也能打消或者降低用户内心的疑虑，更有利于工具的推广和发展</p>',18),s=[p];function d(u,c,h,_,m,g){return a(),t("div",null,s)}const V=e(o,[["render",d]]);export{f as __pageData,V as default};
