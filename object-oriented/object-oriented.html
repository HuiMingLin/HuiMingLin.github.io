<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原型 | Ryan Lin 的小书房</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/0.styles.17f32d1e.css" as="style"><link rel="preload" href="/assets/js/app.7b557cf4.js" as="script"><link rel="preload" href="/assets/js/2.9d2502b9.js" as="script"><link rel="preload" href="/assets/js/24.0ee61759.js" as="script"><link rel="prefetch" href="/assets/js/10.abca38ac.js"><link rel="prefetch" href="/assets/js/11.533a137f.js"><link rel="prefetch" href="/assets/js/12.09bfe638.js"><link rel="prefetch" href="/assets/js/13.6809eae0.js"><link rel="prefetch" href="/assets/js/14.5b42a10c.js"><link rel="prefetch" href="/assets/js/15.581d44ad.js"><link rel="prefetch" href="/assets/js/16.015d76f3.js"><link rel="prefetch" href="/assets/js/17.05f4e776.js"><link rel="prefetch" href="/assets/js/18.be846678.js"><link rel="prefetch" href="/assets/js/19.96606190.js"><link rel="prefetch" href="/assets/js/20.bb2d1d13.js"><link rel="prefetch" href="/assets/js/21.25bb610e.js"><link rel="prefetch" href="/assets/js/22.470a03d7.js"><link rel="prefetch" href="/assets/js/23.ac5167e8.js"><link rel="prefetch" href="/assets/js/25.b5c31bf2.js"><link rel="prefetch" href="/assets/js/26.54c07ad2.js"><link rel="prefetch" href="/assets/js/27.0c2ac7b0.js"><link rel="prefetch" href="/assets/js/3.4de31ec5.js"><link rel="prefetch" href="/assets/js/4.3ff2fe10.js"><link rel="prefetch" href="/assets/js/5.c1f49f56.js"><link rel="prefetch" href="/assets/js/6.8c45e792.js"><link rel="prefetch" href="/assets/js/7.689677a5.js"><link rel="prefetch" href="/assets/js/8.598e5b67.js"><link rel="prefetch" href="/assets/js/9.9fd3d84b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.17f32d1e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Ryan Lin 的小书房</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="原型"><a href="#原型" class="header-anchor">#</a> ** 原型 **</h2> <p><a href="/pages-design-patterns-creation-type-creation-type#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%EF%BC%88%E5%8E%9F%E5%9E%8B%EF%BC%89">(原型模式)</a></p> <h2 id="this"><a href="#this" class="header-anchor">#</a> ** this **</h2> <p>** 在运行时基于函数的执行环境决定，并非函数被声明时的执行环境 **</p> <p>除去不常用的 <code>with</code> 和 <code>eval</code>， 剩下的大致分为 4 种：</p> <ul><li>作为对象的方法调用 （事件绑定函数调用也是，刚学可能不知道）</li> <li>作为普通函数调用</li> <li>作为构造器调用</li> <li>Function.prototype.call 或 Function.prototype.apply 或 Function.prototype.bind 调用。</li></ul> <h3 id="_1、作为对象的方法调用"><a href="#_1、作为对象的方法调用" class="header-anchor">#</a> 1、作为对象的方法调用</h3> <p>当函数作为对象的方法被调用时，this 指向当前对象</p> <ul><li>普通对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  var obj = {
    a: 1,
    getA: function(){
      alert ( this === obj ); // 输出:true
      alert ( this.a ); // 输出: 1
    }
  }
  obj.getA();
</code></pre></div><ul><li>事件绑定函数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  var btn = document.getElementById(&quot;btn&quot;)
  btn.onclick = function () {
    // do sth.
  }
  btn.addEventListener(event type, function ()) {
    // do sth.
  }
</code></pre></div><h3 id="_2、作为普通函数调用"><a href="#_2、作为普通函数调用" class="header-anchor">#</a> 2、作为普通函数调用</h3> <p>当函数作为普通函数调用时，this 指向全局对象，即为 window</p> <ul><li>普通创建函数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  window.name = &quot;globalName&quot;
  var getName = function () {
    return this.name
  }
  console.log(getName()) // globalName
</code></pre></div><ul><li>将某个对象的方法复制给一个全局变量</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  window.name = &quot;globalName&quot;
  var myObjct = {
    name: &quot;myObjct&quot;,
    getName: function () {
      var abc = function () {
        return this.name
      }
      return this.name
    }
  }
  var getName = myObjct.getName
  console.log(getName()) // globalName
</code></pre></div><ul><li>对象方法的内部有一个局部函数</li></ul> <div class="language- extra-class"><pre class="language-text"><code>  window.name = &quot;globalName&quot;
  var myObjct = {
    name: &quot;myObjct&quot;,
    getName: function () {
      var abc = function () {
        return this.name
      }
      return abc()
    }
  }
  console.log(myObjct.getName()) // globalName
</code></pre></div><h3 id="_3、作为构造器调用"><a href="#_3、作为构造器调用" class="header-anchor">#</a> 3、作为构造器调用</h3> <p>当函数作为构造器调用时，this 指向当前实例对象。</p> <p>当用 <code>new</code> 运算符调用函数时，该函数总会返回一个对象，
通常情况下，构造器里的 this 就指向返回的这个对象。</p> <div class="language- extra-class"><pre class="language-text"><code>    var Contructor = function () {
        this.name = &quot;class&quot;
    }
    var obj = new Contructor()
    console.log(obj.name) // class
</code></pre></div><p>当使用 new 调用构造器的时候，
还需要注意一点，如果构造器显示的返一个 object 类型的对象，
那么最终会返回这个对象，而不是我们之前的 <code>this</code>。
如果不显示返回数据，或者返回一个不是对象的数据，就不会造成这个问题。</p> <div class="language- extra-class"><pre class="language-text"><code>    var Contructor = function () {
        this.name = &quot;class&quot;
        return {
            name: 'single'
        }
    }
    var obj = new Contructor()
    console.log(obj.name) // single
</code></pre></div><h3 id="_4、function-prototype-call-或-function-prototype-apply-或-function-prototype-bind-调用"><a href="#_4、function-prototype-call-或-function-prototype-apply-或-function-prototype-bind-调用" class="header-anchor">#</a> 4、Function.prototype.call 或 Function.prototype.apply 或 Function.prototype.bind 调用</h3> <p>可以动态的修改当前 this 对象</p> <div class="language- extra-class"><pre class="language-text"><code>    var obj1 = {
        name: 'obj1',
        getName: function () {
          return this.name;
        }
    };
    var obj2 = {
        name: 'obj2'
    };
    console.log(obj1.getName())             // obj1
    console.log(obj1.getName.call(obj2))    // obj2
    console.log(obj1.getName.apply(obj2))   // obj2
    console.log(obj1.getName.bind(obj2)())  // obj2
</code></pre></div><h2 id="借用其他对象的方法"><a href="#借用其他对象的方法" class="header-anchor">#</a> ** 借用其他对象的方法 **</h2> <p>实现类似继承</p> <div class="language- extra-class"><pre class="language-text"><code>    var A = function( name ){
      this.name = name;
    };
    var B = function(){
      A.apply( this, arguments );
    };
    B.prototype.getName = function(){
      return this.name;
    };
    var b = new B( 'sven' ）
    console.log( b.getName() ); // 输出: 'sven'
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7b557cf4.js" defer></script><script src="/assets/js/2.9d2502b9.js" defer></script><script src="/assets/js/24.0ee61759.js" defer></script>
  </body>
</html>
