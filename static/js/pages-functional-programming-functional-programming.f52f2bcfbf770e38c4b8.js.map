{"version":3,"sources":["webpack:///./pages/functional-programming/functional-programming.mdx"],"names":["MDXContent","props","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","call","layout","React","Component","_this$props","components","_objectWithoutProperties","react__WEBPACK_IMPORTED_MODULE_0___default","a","createElement","_mdx_js_tag__WEBPACK_IMPORTED_MODULE_1__","name","id","parentName"],"mappings":"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","file":"static/js/pages-functional-programming-functional-programming.d32b3108.js","sourcesContent":["\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  \n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><MDXTag name=\"h2\" components={components} props={{\"id\":\"高阶函数\"}}>{`高阶函数`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`高阶函数是指至少满足下列条件之一的函数。`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`函数可以作为参数被传递`}</MDXTag>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`函数可以作为返回值输出`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"1、函数作为参数\"}}>{`1、函数作为参数`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`像 ajax，promise，事件绑定，这些异步行为都会将函数作为回调函数`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  \\$.ajax(\"http://xxx.com/api?\", function(data) {\n    // do sth.\n  });\n\n  new Promise(function (resolve, reject) {\n    // do sth.\n  })\n\n  DOM.addEventListener(event type, function(){\n    // do sth.\n  })\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`还有像 Array#sort, Array#map, Array#filter 都接受一个参数当做参数`}</MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"2、函数作为返回值输出\"}}>{`2、函数作为返回值输出`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`最直接的例子就是 `}<MDXTag name=\"inlineCode\" components={components} parentName=\"p\">{`函数式编程`}</MDXTag></MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  var isType = function( type ){\n    return function( obj ) {\n      return Object.prototype.toString.call( obj ) === '[object '+ type +']';\n    }\n  };\n\n  var isString = isType( 'String' );\n  var isArray = isType( 'Array' );\n  var isNumber = isType( 'Number' );\n  console.log( isArray( [ 1, 2, 3 ] ) ); // true\n`}</MDXTag></MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"高阶函数实现-aop\"}}>{`高阶函数实现 AOP`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，\n这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。\n把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。\n这样做的好处首先是可以保持业务逻辑模块的。\n纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`通常，在 JavaScript 中实现 AOP，都是指把一个函数“动态织入”到另外一个函数之中，具体的实现技术有很多，\n本节我们通过扩展 Function.prototype 来做到这一点。代码如下:`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  Function.prototype.before = function(beforefn) {\n    var __self = this; // 保存原函数的引用\n    return function() {\n      // 返回包含了原函数和新函数的\"代理\"函数\n      beforefn.apply(this, arguments);\n      return __self.apply(this, arguments);\n    };\n  };\n\n  Function.prototype.after = function(afterfn) {\n    var __self = this;\n    return function() {\n      // 执行新函数，修正 this // 执行原函数\n      var ret = __self.apply(this, arguments);\n      afterfn.apply(this, arguments);\n      return ret;\n    };\n  };\n\n  var func = function() {\n    console.log(2);\n  };\n\n  func = func\n    .before(function() {\n      console.log(1);\n    })\n    .after(function() {\n      console.log(3);\n    });\n\n  func();\n`}</MDXTag></MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"3、高阶函数的其他应用\"}}>{`3、高阶函数的其他应用`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`curry 柯里化`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`柯里化被称为局部求值，函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来\n只有当传入的函数参数数量等于形参的时候，函数才会调用。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`    var curryN = function(fn) {\n      var args = [];\n      return function curryed() {\n        var innerArgs = [].slice.call(arguments);\n        args = args.concat(innerArgs);\n        if (fn.length <= args.length) {\n          return fn.apply(this, args);\n        } else {\n          return curryed;\n        }\n      };\n    };\n`}</MDXTag></MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`uncurry\n一个对象也未必只能使用它自身的方法，那么有什么办法可以让对象去借用一个原本不属于它的方法呢?`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  var obj1 = { name: \"sven\" };\n  var obj2 = {\n    getName: function() {\n      return this.name;\n    }\n  };\n  console.log(obj2.getName.call(obj1));  // 输出:sven\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`这是最常用的，但是如何转换 getName 转换为通用的函数呢？`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  Function.prototype.uncurrying = function() {\n    var self = this;\n    return function() {\n      var obj = Array.prototype.shift.call(arguments);\n      return self.apply(obj, arguments);\n    };\n  };\n\n  var getName = obj2.getName.uncurrying();\n  console.log(getName(obj1))\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`另一种写法：`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  Function.prototype.uncurrying = function(){\n    var self = this;\n    return function () {\n      return Function.prototype.call.apply( self, arguments );\n    }\n  };\n`}</MDXTag></MDXTag>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}