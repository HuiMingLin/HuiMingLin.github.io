{"version":3,"sources":["webpack:///./pages/performance-optimization/performance-optimization.mdx"],"names":["MDXContent","props","_this","_classCallCheck","this","_possibleConstructorReturn","_getPrototypeOf","call","layout","React","Component","_this$props","components","_objectWithoutProperties","react__WEBPACK_IMPORTED_MODULE_0___default","a","createElement","_mdx_js_tag__WEBPACK_IMPORTED_MODULE_1__","name","id","parentName"],"mappings":"y8CAQqBA,cACnB,SAAAA,EAAYC,GAAO,IAAAC,EAAA,mGAAAC,CAAAC,KAAAJ,IACjBE,EAAAG,EAAAD,KAAAE,EAAAN,GAAAO,KAAAH,KAAMH,KACDO,OAAS,KAFGN,yPADmBO,IAAMC,kDAKnC,IAAAC,EAC0BP,KAAKH,MAA9BW,EADDD,EACCC,WADDC,EAAAF,EAAA,gBAGP,OAAOG,EAAAC,EAAAC,cAACC,EAAA,OAAD,CACEC,KAAK,UAELN,WAAYA,GAAYE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYX,MAAO,CAACkB,GAAK,6BAAvD,4BACrCL,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,kLACAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,4BACAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYX,MAAO,CAACkB,GAAK,wEAAvD,uEACAL,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,GAC9BE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYQ,WAAW,MAArD,iCAEAN,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,0iBAGAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,GAC9BE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYQ,WAAW,MAArD,2BAEAN,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,8QAEAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,GAC9BE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYQ,WAAW,MAArD,6BAEAN,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,wtBAGAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYX,MAAO,CAACkB,GAAK,sDAAvD,qDACAL,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,m/BAKAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYX,MAAO,CAACkB,GAAK,kEAAvD,iEACAL,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,6lBAGAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,MAAMN,WAAYA,GAAYE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,OAAON,WAAYA,EAAYQ,WAAW,MAAMnB,MAAO,IAApE,iiBA2B3Ca,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYX,MAAO,CAACkB,GAAK,6BAAvD,4BACAL,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,+xBAGAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,8VAEAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,oYAEAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,MAAMN,WAAYA,GAAYE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,OAAON,WAAYA,EAAYQ,WAAW,MAAMnB,MAAO,IAApE,kqBAqB3Ca,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,KAAKN,WAAYA,EAAYX,MAAO,CAACkB,GAAK,yCAAvD,wCACAL,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,uZAEAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,MAAMN,WAAYA,GAAYE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,OAAON,WAAYA,EAAYQ,WAAW,MAAMnB,MAAO,IAApE,mQAS3Ca,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,ubAEAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,2bAEAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,MAAMN,WAAYA,GAAYE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,OAAON,WAAYA,EAAYQ,WAAW,MAAMnB,MAAO,IAApE,sVAa3Ca,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,ybAEAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,IAAIN,WAAYA,GAA7B,8wBAIAE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,MAAMN,WAAYA,GAAYE,EAAAC,EAAAC,cAACC,EAAA,OAAD,CAAQC,KAAK,OAAON,WAAYA,EAAYQ,WAAW,MAAMnB,MAAO,IAApE","file":"static/js/pages-performance-optimization-performance-optimization.3e0f3507.js","sourcesContent":["\n  import React from 'react'\n  import { MDXTag } from '@mdx-js/tag'\n  \n\nconst layoutProps = {\n  \n};\nexport default class MDXContent extends React.Component {\n  constructor(props) {\n    super(props)\n    this.layout = null\n  }\n  render() {\n    const { components, ...props } = this.props\n\n    return <MDXTag\n             name=\"wrapper\"\n             \n             components={components}><MDXTag name=\"h2\" components={components} props={{\"id\":\"函数节流\"}}>{`函数节流`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在默写情况下函数可能会被频繁的调用，然后造成大的性能问题。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`举个例子`}</MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"1、函数被频繁调用的场景\"}}>{`1、函数被频繁调用的场景`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`window.onresize 事件`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`当为 window 绑定 resize 事件时， 并且浏览器窗口被拖动时，会频繁的触发 resize 事件时，\n如果在事件中在获取一些元素的位置，执行一些 DOM 操作，性能消耗会更大，如自己实现一个滚动条。\n这时候浏览器就会造成卡顿。`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`mousemove 事件`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`如果我们给一个 div 节点绑定了一个拖拽事件 （mousemove or dragmove), 当节点被拖动时，\n也会频繁地触发拖拽事件。`}</MDXTag>\n<MDXTag name=\"ul\" components={components}>\n<MDXTag name=\"li\" components={components} parentName=\"ul\">{`上传进度`}</MDXTag>\n</MDXTag>\n<MDXTag name=\"p\" components={components}>{`微云的上传功能使用了公司提供的一个浏览器插件。\n该浏览器插件在真正开始上传文件之前，会对文件进行扫描并随时通知 JavaScript 函数，以便在页面中显示当前 的扫描进度。\n但该插件通知的频率非常之高，大约一秒钟 10 次，很显然我们在页面中不 需要如此频繁地去提示用户。`}</MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"2、函数节流的原理\"}}>{`2、函数节流的原理`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`我们整理上面提到的三个场景，发现它们面临的共同问题是函数被触发的频率太高。\n比如我们在 window.onresize 事件中要打印当前的浏览器窗口大小，\n在我们通过拖曳来改变 窗口大小的时候，打印窗口大小的工作 1 秒钟进行了 10 次。而我们实际上只需要 2 次或者 3 次。\n这就需要我们按时间段来忽略掉一些事件请求，比如确保在 500ms 内只打印一次。\n很显然，我们 可以借助 setTimeout 来完成这件事情。`}</MDXTag>\n<MDXTag name=\"h3\" components={components} props={{\"id\":\"3、函数节流的代码实现\"}}>{`3、函数节流的代码实现`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`throttle 函数的原理是，将即将被执行的函数用 setTimeout 延迟一段时间执行。\n如果该次延迟执行还没有完成，则忽略接下来调用该函数的请求。\nthrottle 函数接受 2 个参数，第一个参数为需要被延迟执行的函数，第二个参数为延迟执行的时间。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  var throttle = function(fn, interval) {\n    var _self = fn,\n      timer = null,\n      firstTime = true;\n    interval = interval || 50;\n\n    return function() {\n      var args = arguments,\n        _me = this;\n\n      if (firstTime) {\n        _self.apply(_me, args);\n        return (firstTime = false);\n      }\n\n      if (timer) {\n        return false;\n      }\n\n      timer = setTimeout(function() {\n        clearTimeout(timer);\n        timer = null;\n        _self.apply(_me, args);\n      }, interval);\n    };\n  };\n`}</MDXTag></MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"分时函数\"}}>{`分时函数`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`一个例子是创建 WebQQ 的 QQ 好友列表。列表中通常会有成百上千个好友，\n如果一个好友 用一个节点来表示，当我们在页面中渲染这个列表的时候，可能要一次性往页面中创建成百上千个节点。\n在短时间内往页面中大量添加 DOM 节点显然也会让浏览器吃不消，我们看到的结果往往就是浏览器的卡顿甚至假死。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`解决方案之一是下面的 timeChunk 函数，timeChunk 函数让创建节点的工作分批进\n行，比如把 1 秒钟创建 1000 个节点，改为每隔 200 毫秒创建 8 个节点。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`timeChunk 函数接受 3 个参。\n第 1 个参数是创建节点时需要用到的数据，第 2 个参数是封装了创建节点逻辑的函数，第 3 个参数表示每一批创建的节点数量。`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  var timeChunk = function(ary, fn, count) {\n    var obj, t;\n    var len = ary.length;\n    var start = function() {\n      for (var i = 0; i < Math.min(count || 1, ary.length); i++) {\n        var obj = ary.shift();\n        fn(obj);\n      }\n    };\n\n    return function() {\n      t = setInterval(function() {\n        if (ary.length === 0) {\n          // 如果全部节点都已经被创建好\n          return clearInterval(t);\n        }\n        start();\n      }, 200); // 分批执行的时间间隔，也可以用参数的形式传入\n    };\n  };\n`}</MDXTag></MDXTag>\n<MDXTag name=\"h2\" components={components} props={{\"id\":\"惰性加载函数\"}}>{`惰性加载函数`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`在 Web 开发中，因为浏览器之间的实现差异，一些嗅探工作总是不可避免。比如我们需要\n一个在各个浏览器中能够通用的事件绑定函数 addEvent, 常见的写法如下:`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  var addEvent = function(elem, type, handler) {\n    if (window.addEventListener) {\n      return elem.addEventListener(type, handler, false);\n    }\n    if ( window.attachEvent ){\n      return elem.attachEvent( 'on' + type, handler ); \n    }\n  };\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`这个函数的缺点是，当它每次被调用的时候都会执行里面的 if 条件分支，虽然执行这些 if\n分支的开销不算大，但也许有一些方法可以让程序避免这些重复的执行过程。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`第二种方案是这样，我们把嗅探浏览器的操作提前到代码加载的时候，在代码加载的时候就\n立刻进行一次判断，以便让 addEvent 返回一个包裹了正确逻辑的函数。代码如下:`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  var addEvent = (function() {\n    if (window.addEventListener) {\n      return function(elem, type, handler) {\n        elem.addEventListener(type, handler, false);\n      };\n    }\n    if (window.attachEvent) {\n      return function(elem, type, handler) {\n        elem.attachEvent(\"on\" + type, handler);\n      };\n    }\n  })();\n`}</MDXTag></MDXTag>\n<MDXTag name=\"p\" components={components}>{`目前的 addEvent 函数依然有个缺点，也许我们从头到尾都没有使用过 addEvent 函数，这样看\n来，前一次的浏览器嗅探就是完全多余的操作，而且这也会稍稍延长页面 ready 的时间。`}</MDXTag>\n<MDXTag name=\"p\" components={components}>{`第三种方案即是我们将要讨论的惰性载入函数方案。\n此时 addEvent 依然被声明为一个普通函数，在函数里依然有一些分支判断。\n但是在第一次进入条件分支之后，在函数内部会重写这个函数，重写之后的函数就是我们期望的 addEvent 函数，\n在下一次进入 addEvent 函数的时候，addEvent 函数里不再存在条件分支语句:`}</MDXTag>\n<MDXTag name=\"pre\" components={components}><MDXTag name=\"code\" components={components} parentName=\"pre\" props={{}}>{`  var addEvent = function(elem, type, handler) {\n    if (window.addEventListener) {\n      addEvent = function(elem, type, handler) {\n        elem.addEventListener(type, handler, false);\n      };\n    } else if (window.attachEvent) {\n      addEvent = function(elem, type, handler) {\n        elem.attachEvent(\"on\" + type, handler);\n      };\n    }\n    addEvent(elem, type, handler);\n  };\n\n  var div = document.getElementById(\"div1\");\n  addEvent(div, \"click\", function() {\n    alert(1);\n  });\n  addEvent(div, \"click\", function() {\n    alert(2);\n  });\n`}</MDXTag></MDXTag>\n           </MDXTag>\n  }\n}\n  "],"sourceRoot":""}