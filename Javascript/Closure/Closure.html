<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Ryan Lin 的小书房</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/0.styles.17f32d1e.css" as="style"><link rel="preload" href="/assets/js/app.7b557cf4.js" as="script"><link rel="preload" href="/assets/js/2.9d2502b9.js" as="script"><link rel="preload" href="/assets/js/6.8c45e792.js" as="script"><link rel="prefetch" href="/assets/js/10.abca38ac.js"><link rel="prefetch" href="/assets/js/11.533a137f.js"><link rel="prefetch" href="/assets/js/12.09bfe638.js"><link rel="prefetch" href="/assets/js/13.6809eae0.js"><link rel="prefetch" href="/assets/js/14.5b42a10c.js"><link rel="prefetch" href="/assets/js/15.581d44ad.js"><link rel="prefetch" href="/assets/js/16.015d76f3.js"><link rel="prefetch" href="/assets/js/17.05f4e776.js"><link rel="prefetch" href="/assets/js/18.be846678.js"><link rel="prefetch" href="/assets/js/19.96606190.js"><link rel="prefetch" href="/assets/js/20.bb2d1d13.js"><link rel="prefetch" href="/assets/js/21.25bb610e.js"><link rel="prefetch" href="/assets/js/22.470a03d7.js"><link rel="prefetch" href="/assets/js/23.ac5167e8.js"><link rel="prefetch" href="/assets/js/24.0ee61759.js"><link rel="prefetch" href="/assets/js/25.b5c31bf2.js"><link rel="prefetch" href="/assets/js/26.54c07ad2.js"><link rel="prefetch" href="/assets/js/27.0c2ac7b0.js"><link rel="prefetch" href="/assets/js/3.4de31ec5.js"><link rel="prefetch" href="/assets/js/4.3ff2fe10.js"><link rel="prefetch" href="/assets/js/5.c1f49f56.js"><link rel="prefetch" href="/assets/js/7.689677a5.js"><link rel="prefetch" href="/assets/js/8.598e5b67.js"><link rel="prefetch" href="/assets/js/9.9fd3d84b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.17f32d1e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Ryan Lin 的小书房</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><p>** 闭包的形成与变量的作用域以及变量的生存周期密切相关 **</p> <h2 id="作用域"><a href="#作用域" class="header-anchor">#</a> 作用域</h2> <h3 id="全局作用域"><a href="#全局作用域" class="header-anchor">#</a> 全局作用域</h3> <p>在这个作用域上创建的变量，都会挂载到 window 上， 成为全局变量，也是最外层的作用域。</p> <div class="language- extra-class"><pre class="language-text"><code>  var globalA = 'globalA';
  var globalB = &quot;globalB&quot;;

  var add = function (a, b) {
    return a + b;
  }
</code></pre></div><h3 id="函数作用域"><a href="#函数作用域" class="header-anchor">#</a> 函数作用域</h3> <p>当创建一个函数时，通过 <code>var</code> 创建的变量都是该函数的局部变量, 在函数外部是访问不到的，在函数调用之后这些变量会被垃圾回收机制回收。
但是当创建变量不通过 <code>var</code> 时，创建的变量会变成全局变量。全局变量是不会被回收的，除非关闭浏览器或者手动删除该属性。</p> <div class="language- extra-class"><pre class="language-text"><code>  var globalA = 'globalA';
  var add = function (a, b) {
    globalA = 'globalB';
    var addA = 'add';
    return a + b;
  }
  console.log(window.globalA); // globalA
  add()
  console.log(window.globalA); // globalB
  console.log(addA) // Uncaught ReferenceError: addA is not defined
</code></pre></div><h3 id="块作用域"><a href="#块作用域" class="header-anchor">#</a> 块作用域</h3> <p>块作用域是 ES6 添加的，ES5之前是没有块作用域的。</p> <p>举个例子：</p> <ul><li>html</li></ul> <div class="language- extra-class"><pre class="language-text"><code>    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
    &lt;li&gt;6&lt;/li&gt;
    &lt;li&gt;7&lt;/li&gt;
    &lt;li&gt;8&lt;/li&gt;
    &lt;li&gt;9&lt;/li&gt;
    &lt;li&gt;9&lt;/li&gt;
</code></pre></div><ul><li>js</li></ul> <div class="language- extra-class"><pre class="language-text"><code>    var lis = document.getElementsByTagName('li');
    var len = lis.length;
    
    for (var i = 0; i &lt; len; i++) {
      lis[i].onclick = function () {
        console.log(i); // 点击任意一个都输出 9
      }
    }
    console.log(window.i); // 9
</code></pre></div><p>这是因为 li 节点的 onclick 事件是被异步触发的，当事件被触发的时候，for 循环早已结束，
此时变量 i 的值已经是 9，所以在 li 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时，查找到的值总是 9,
可以通过 <code>let</code> 和 <code>闭包</code> 解决。</p> <p>因为 ES6 之前没有块作用域， 所以变量 <code>i</code> 会成为全局变量，可以通过 <code>window.i</code> 访问。</p> <p>在 ES6 中通过 <code>let</code> 代替 var 声明变量，实现块作用域。</p> <ul><li>js</li></ul> <div class="language- extra-class"><pre class="language-text"><code>    let lis = document.getElementsByTagName('li');
    let len = lis.length;
    
    for (let i = 0; i &lt; len; i++) {
      lis[i].onclick = function () {
        console.log(i);
      }
    }
    console.log(window.i); // undefined
</code></pre></div><h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <p>访问变量的顺序</p> <div class="language- extra-class"><pre class="language-text"><code>  var name = 'ryan'
  var getName = function () {
    return name;
  }
  console.log(getName()) // ryan


  var name = 'ryan'
  var getName = function () {
    var name = 'sally'
    return name;
  }
  console.log(getName()) // sally

  var name = 'ryan'
  var getName = function () {
    var name = 'sally'
    return function () {
      return name;
    };
  }
  console.log(getName()) // sally

  var name = 'ryan'
  var getName = function () {
    var name = 'sally'
    return function () {
      var name = 'marry'
      return name;
    };
  }
  console.log(getName()) // marry
</code></pre></div><p>在函数作用域中，最内层的函数可以访问它的上一层函数的作用域（变量和内部函数），直至全局作用域。
当访问一个最内层函数没有的变量时，就会往上一层找，直至找到或者undefined。</p> <p>闭包就是通过函数作用域创建一个函数，为某个作用域创建一个独立作用域, 并且返回一个函数。
在闭包的帮助下，把每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链中从内到外查找变量 i 时，会先找到被封闭在闭包环境中的 i。</p> <div class="language- extra-class"><pre class="language-text"><code>  var lis = document.getElementsByTagName('li');
  var len = lis.length;
    
  for (var i = 0; i &lt; len; i++) {
    lis[i].onclick = (function (i) {
      return function () {
        console.log(i);
      }
    })(i)
  }
  console.log(window.i); // 9
</code></pre></div><p>这样当点击 li 的时候，会访问 <code>IIFE</code> 创建的那个作用域，而且我们将 for 循环的 i 作为参数传入到 IIFE 中。</p> <p>再看一下另外一种写法：</p> <div class="language- extra-class"><pre class="language-text"><code>  var clickFn = function (i) {
    // 这个作用域里有一个变量 i
    return function () {
      console.log(i);
    }
  }

  for (var i = 0; i &lt; len; i++) {
    lis[i].onclick = clickFn(i)
  }
  console.log(window.i); // 9
</code></pre></div><p>都是为了能为每一个 li 的绑定事件函数传入不同的 i。</p> <p>按照 <code>JavaScript引擎</code> 函数在调用完成之后变量会被垃圾回收机制回收，那为什么我们访问输出 i 的时候，好像变量 i 没有消失呢？
这是闭包的另外一个能力。</p> <p>除了保证每次传入的都是唯一并且不同的值，并且这个变量不会被回收，因为当你点击 li 的时候所调用的函数需要变量 i，
<code>JavaScript引擎</code> 发现被调用的函数里没有变量 i， 只能通过作用域一层层往上找， 所以找到了被当做参数的变量 i。
发现变量 i 还需要被用到，所以不会被回收。而且这个函数作用域里的其他的变量也是可以访问，这在之前说过。</p> <h2 id="闭包更多作用"><a href="#闭包更多作用" class="header-anchor">#</a> 闭包更多作用</h2> <ul><li>封装变量</li></ul> <p>假如我们写一个库， 里面包含了两个函数。</p> <div class="language- extra-class"><pre class="language-text"><code>  var add = function (a, b) {
    return a + b;
  }  
  var multiply = function (a, b) {
    return a * b;
  }  
</code></pre></div><p>当别人引用这个库的时候，别人的代码里也有这两个函数的时候，这时候函数会被覆盖。
所以我们用一个全局变量来存储它，并且通过闭包使这两个函数只能通过内部访问，
减少全局变量的污染。</p> <div class="language- extra-class"><pre class="language-text"><code>  var R = (function () {
    var add = function (a, b) {
      return a + b;
    }  
    var multiply = function (a, b) {
      return a * b;
    }  

    return {
      add: add,
      multiply: multiply
    } 
  })()
</code></pre></div><p>这下我们将函数只能 R 内部访问，并且暴露出一个 全局变量 R。</p> <ul><li>延续局部变量的寿命</li></ul> <p>img 对象经常用于进行数据上报，如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>  var report = function( src )   { 
    var img = new Image();
    img.src = src;
  };

  report( 'http://xxx.com/getUserInfo' );
</code></pre></div><p>但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，
在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据。</p> <p>也就是说，report 函数并不是每一次 都成功发起了 HTTP 请求。
丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的 调用结束后，img 局部变量随即被销毁，
而此时或许还没来得及发出 HTTP 请求，所以此次请求 就会丢失掉。</p> <p>现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题:</p> <div class="language- extra-class"><pre class="language-text"><code>  var report = (function(){ var imgs = [];
    return function(src){
    var img = new Image(); 
    imgs.push( img ); 
    img.src = src;
  }})();
</code></pre></div><h2 id="闭包造成的内存泄漏"><a href="#闭包造成的内存泄漏" class="header-anchor">#</a> 闭包造成的内存泄漏</h2> <p>闭包是一个非常强大的特性，但人们对其也有诸多误解。一种耸人听闻的说法是闭包会造成内存泄露，所以要尽量减少闭包的使用。</p> <p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。
从这个意义上看，闭包的确会使一些数据无法被及时销毁。
使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，
因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。
如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7b557cf4.js" defer></script><script src="/assets/js/2.9d2502b9.js" defer></script><script src="/assets/js/6.8c45e792.js" defer></script>
  </body>
</html>
