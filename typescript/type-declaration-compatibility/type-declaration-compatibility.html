<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类型兼容 | Ryan Lin 的知识库</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/assets/css/0.styles.2257f275.css" as="style"><link rel="preload" href="/assets/js/app.5dd33da1.js" as="script"><link rel="preload" href="/assets/js/2.bffc4eaa.js" as="script"><link rel="preload" href="/assets/js/142.bfb1dbf7.js" as="script"><link rel="prefetch" href="/assets/js/10.870f5dc0.js"><link rel="prefetch" href="/assets/js/100.7b5b4a95.js"><link rel="prefetch" href="/assets/js/101.421b0ac2.js"><link rel="prefetch" href="/assets/js/102.a38980c8.js"><link rel="prefetch" href="/assets/js/103.70f1c866.js"><link rel="prefetch" href="/assets/js/104.e2e5ecf5.js"><link rel="prefetch" href="/assets/js/105.811e1ad5.js"><link rel="prefetch" href="/assets/js/106.7cfaa290.js"><link rel="prefetch" href="/assets/js/107.e4be3fbb.js"><link rel="prefetch" href="/assets/js/108.4d49b79b.js"><link rel="prefetch" href="/assets/js/109.826ec2d5.js"><link rel="prefetch" href="/assets/js/11.bdfbc35d.js"><link rel="prefetch" href="/assets/js/110.da6bf348.js"><link rel="prefetch" href="/assets/js/111.97f70188.js"><link rel="prefetch" href="/assets/js/112.0f327158.js"><link rel="prefetch" href="/assets/js/113.089311f1.js"><link rel="prefetch" href="/assets/js/114.7d8b7c9a.js"><link rel="prefetch" href="/assets/js/115.8d50a48b.js"><link rel="prefetch" href="/assets/js/116.cfe881cd.js"><link rel="prefetch" href="/assets/js/117.82d65d4d.js"><link rel="prefetch" href="/assets/js/118.1ae016ef.js"><link rel="prefetch" href="/assets/js/119.b3b2d52d.js"><link rel="prefetch" href="/assets/js/12.0b3b3179.js"><link rel="prefetch" href="/assets/js/120.7fcc49a1.js"><link rel="prefetch" href="/assets/js/121.e600fcbe.js"><link rel="prefetch" href="/assets/js/122.fd5e613e.js"><link rel="prefetch" href="/assets/js/123.e0c1546c.js"><link rel="prefetch" href="/assets/js/124.e62ad441.js"><link rel="prefetch" href="/assets/js/125.a60c13b4.js"><link rel="prefetch" href="/assets/js/126.9e990ea1.js"><link rel="prefetch" href="/assets/js/127.b54e3b82.js"><link rel="prefetch" href="/assets/js/128.3fb6b56d.js"><link rel="prefetch" href="/assets/js/129.5001dcc2.js"><link rel="prefetch" href="/assets/js/13.80c562df.js"><link rel="prefetch" href="/assets/js/130.a9e2d1b7.js"><link rel="prefetch" href="/assets/js/131.bfdf1f70.js"><link rel="prefetch" href="/assets/js/132.5218e22c.js"><link rel="prefetch" href="/assets/js/133.cb171ec1.js"><link rel="prefetch" href="/assets/js/134.7a6e7332.js"><link rel="prefetch" href="/assets/js/135.784e4bab.js"><link rel="prefetch" href="/assets/js/136.1c23757a.js"><link rel="prefetch" href="/assets/js/137.3b1ec706.js"><link rel="prefetch" href="/assets/js/138.855f1c2a.js"><link rel="prefetch" href="/assets/js/139.c90851a3.js"><link rel="prefetch" href="/assets/js/14.acb9028c.js"><link rel="prefetch" href="/assets/js/140.2cff4fc4.js"><link rel="prefetch" href="/assets/js/141.ee58e250.js"><link rel="prefetch" href="/assets/js/143.21726dc3.js"><link rel="prefetch" href="/assets/js/144.389f3dc8.js"><link rel="prefetch" href="/assets/js/145.add89c86.js"><link rel="prefetch" href="/assets/js/146.dcf7f250.js"><link rel="prefetch" href="/assets/js/147.30abbce2.js"><link rel="prefetch" href="/assets/js/148.80dc05ea.js"><link rel="prefetch" href="/assets/js/149.784dba4f.js"><link rel="prefetch" href="/assets/js/15.f2010fd2.js"><link rel="prefetch" href="/assets/js/150.21e0cc84.js"><link rel="prefetch" href="/assets/js/151.b5ca6141.js"><link rel="prefetch" href="/assets/js/152.15638869.js"><link rel="prefetch" href="/assets/js/153.af195f3c.js"><link rel="prefetch" href="/assets/js/154.8eb510c9.js"><link rel="prefetch" href="/assets/js/155.fd909e60.js"><link rel="prefetch" href="/assets/js/156.5cb98435.js"><link rel="prefetch" href="/assets/js/157.8a6df4f7.js"><link rel="prefetch" href="/assets/js/158.34b28d06.js"><link rel="prefetch" href="/assets/js/159.8879e485.js"><link rel="prefetch" href="/assets/js/16.343605fc.js"><link rel="prefetch" href="/assets/js/160.670bd93d.js"><link rel="prefetch" href="/assets/js/161.ce94a130.js"><link rel="prefetch" href="/assets/js/162.ef2f8e1d.js"><link rel="prefetch" href="/assets/js/163.2e925133.js"><link rel="prefetch" href="/assets/js/164.f06af007.js"><link rel="prefetch" href="/assets/js/165.5ca95b73.js"><link rel="prefetch" href="/assets/js/166.3ddb19d3.js"><link rel="prefetch" href="/assets/js/167.14958591.js"><link rel="prefetch" href="/assets/js/168.361fc960.js"><link rel="prefetch" href="/assets/js/169.cbf0929a.js"><link rel="prefetch" href="/assets/js/17.51faa4cc.js"><link rel="prefetch" href="/assets/js/170.8d98e721.js"><link rel="prefetch" href="/assets/js/171.78f2edb4.js"><link rel="prefetch" href="/assets/js/172.79b4b7a2.js"><link rel="prefetch" href="/assets/js/173.e252060f.js"><link rel="prefetch" href="/assets/js/174.4a84df1a.js"><link rel="prefetch" href="/assets/js/175.3f3ad04a.js"><link rel="prefetch" href="/assets/js/176.1b5511a7.js"><link rel="prefetch" href="/assets/js/177.edbcde74.js"><link rel="prefetch" href="/assets/js/18.f5710dc1.js"><link rel="prefetch" href="/assets/js/19.8da124bc.js"><link rel="prefetch" href="/assets/js/20.91af6434.js"><link rel="prefetch" href="/assets/js/21.18968b63.js"><link rel="prefetch" href="/assets/js/22.65a90243.js"><link rel="prefetch" href="/assets/js/23.5f72be9f.js"><link rel="prefetch" href="/assets/js/24.6771af23.js"><link rel="prefetch" href="/assets/js/25.6e233549.js"><link rel="prefetch" href="/assets/js/26.cd6e21b0.js"><link rel="prefetch" href="/assets/js/27.1ed02dde.js"><link rel="prefetch" href="/assets/js/28.35563828.js"><link rel="prefetch" href="/assets/js/29.081e3a6a.js"><link rel="prefetch" href="/assets/js/3.e786b54c.js"><link rel="prefetch" href="/assets/js/30.12c70eec.js"><link rel="prefetch" href="/assets/js/31.ffad65a3.js"><link rel="prefetch" href="/assets/js/32.46538c35.js"><link rel="prefetch" href="/assets/js/33.d37fc397.js"><link rel="prefetch" href="/assets/js/34.5224d1e9.js"><link rel="prefetch" href="/assets/js/35.03a9ce0f.js"><link rel="prefetch" href="/assets/js/36.d28870aa.js"><link rel="prefetch" href="/assets/js/37.a87884bc.js"><link rel="prefetch" href="/assets/js/38.c3342c9e.js"><link rel="prefetch" href="/assets/js/39.2335df59.js"><link rel="prefetch" href="/assets/js/4.bd730c56.js"><link rel="prefetch" href="/assets/js/40.abea8e3a.js"><link rel="prefetch" href="/assets/js/41.6e134625.js"><link rel="prefetch" href="/assets/js/42.40f88039.js"><link rel="prefetch" href="/assets/js/43.16571ff8.js"><link rel="prefetch" href="/assets/js/44.456cb65e.js"><link rel="prefetch" href="/assets/js/45.9fe05289.js"><link rel="prefetch" href="/assets/js/46.5849813f.js"><link rel="prefetch" href="/assets/js/47.51ef2a1d.js"><link rel="prefetch" href="/assets/js/48.9ecdc4bd.js"><link rel="prefetch" href="/assets/js/49.98f93378.js"><link rel="prefetch" href="/assets/js/5.6b60ba93.js"><link rel="prefetch" href="/assets/js/50.9aa5f2f6.js"><link rel="prefetch" href="/assets/js/51.2aa8cec6.js"><link rel="prefetch" href="/assets/js/52.c815ff1e.js"><link rel="prefetch" href="/assets/js/53.d7ccf15e.js"><link rel="prefetch" href="/assets/js/54.b690923e.js"><link rel="prefetch" href="/assets/js/55.2b4c377e.js"><link rel="prefetch" href="/assets/js/56.6b0f9e02.js"><link rel="prefetch" href="/assets/js/57.a0f83ca8.js"><link rel="prefetch" href="/assets/js/58.30731a9c.js"><link rel="prefetch" href="/assets/js/59.2395bfc6.js"><link rel="prefetch" href="/assets/js/6.e9b450da.js"><link rel="prefetch" href="/assets/js/60.0c0ca421.js"><link rel="prefetch" href="/assets/js/61.a2faf842.js"><link rel="prefetch" href="/assets/js/62.adf8e39e.js"><link rel="prefetch" href="/assets/js/63.a27bd613.js"><link rel="prefetch" href="/assets/js/64.94dac151.js"><link rel="prefetch" href="/assets/js/65.09b09746.js"><link rel="prefetch" href="/assets/js/66.51a4f648.js"><link rel="prefetch" href="/assets/js/67.ad4d01cb.js"><link rel="prefetch" href="/assets/js/68.210b5fec.js"><link rel="prefetch" href="/assets/js/69.0d338524.js"><link rel="prefetch" href="/assets/js/7.09fe4966.js"><link rel="prefetch" href="/assets/js/70.e0c73a22.js"><link rel="prefetch" href="/assets/js/71.e8e85b12.js"><link rel="prefetch" href="/assets/js/72.f041b008.js"><link rel="prefetch" href="/assets/js/73.125fb898.js"><link rel="prefetch" href="/assets/js/74.0df75098.js"><link rel="prefetch" href="/assets/js/75.e8fd2a19.js"><link rel="prefetch" href="/assets/js/76.cbae0e4b.js"><link rel="prefetch" href="/assets/js/77.5383c235.js"><link rel="prefetch" href="/assets/js/78.f6192123.js"><link rel="prefetch" href="/assets/js/79.49003bd1.js"><link rel="prefetch" href="/assets/js/8.0c82c132.js"><link rel="prefetch" href="/assets/js/80.11d69d10.js"><link rel="prefetch" href="/assets/js/81.3f204432.js"><link rel="prefetch" href="/assets/js/82.c03c5548.js"><link rel="prefetch" href="/assets/js/83.b24468bb.js"><link rel="prefetch" href="/assets/js/84.aeb945dd.js"><link rel="prefetch" href="/assets/js/85.9ea8a4ed.js"><link rel="prefetch" href="/assets/js/86.f7c226d3.js"><link rel="prefetch" href="/assets/js/87.1b3a548f.js"><link rel="prefetch" href="/assets/js/88.9a54dbc6.js"><link rel="prefetch" href="/assets/js/89.2f907505.js"><link rel="prefetch" href="/assets/js/9.95f4c5c2.js"><link rel="prefetch" href="/assets/js/90.03530653.js"><link rel="prefetch" href="/assets/js/91.27822bbf.js"><link rel="prefetch" href="/assets/js/92.613514fb.js"><link rel="prefetch" href="/assets/js/93.e06e0e69.js"><link rel="prefetch" href="/assets/js/94.c4a392f0.js"><link rel="prefetch" href="/assets/js/95.a80003aa.js"><link rel="prefetch" href="/assets/js/96.ac6481f9.js"><link rel="prefetch" href="/assets/js/97.305dfef5.js"><link rel="prefetch" href="/assets/js/98.ce4f0bd3.js"><link rel="prefetch" href="/assets/js/99.831c25bb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2257f275.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/img/logo.jpg" alt="Ryan Lin 的知识库" class="logo"> <span class="site-name can-hide">Ryan Lin 的知识库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  关于我
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Typescript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/typescript/overview/overview.html" class="sidebar-link">概览</a></li><li><a href="/typescript/type/type.html" class="sidebar-link">基础类型</a></li><li><a href="/typescript/type-system-hierarchy/type-system-hierarchy.html" class="sidebar-link">类型系统层级</a></li><li><a href="/typescript/type-guard/type-guard.html" class="sidebar-link">类型守卫</a></li><li><a href="/typescript/type-declaration-extension/type-declaration-extension.html" class="sidebar-link">类型声明扩展</a></li><li><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html" aria-current="page" class="active sidebar-link">类型兼容</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#结构化类型" class="sidebar-link">结构化类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#定义和示例" class="sidebar-link">定义和示例</a></li><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#鸭子类型的局限性" class="sidebar-link">鸭子类型的局限性</a></li><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#最佳实践" class="sidebar-link">最佳实践</a></li></ul></li><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#协变和逆变" class="sidebar-link">协变和逆变</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#协变-covariance" class="sidebar-link">协变（Covariance）</a></li><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#逆变-contravariance" class="sidebar-link">逆变（Contravariance）</a></li><li class="sidebar-sub-header"><a href="/typescript/type-declaration-compatibility/type-declaration-compatibility.html#协变与逆变的平衡" class="sidebar-link">协变与逆变的平衡</a></li></ul></li></ul></li><li><a href="/typescript/statement/statement.html" class="sidebar-link">声明</a></li><li><a href="/typescript/interface/interface.html" class="sidebar-link">接口</a></li><li><a href="/typescript/class/class.html" class="sidebar-link">类</a></li><li><a href="/typescript/function/function.html" class="sidebar-link">函数</a></li><li><a href="/typescript/genericity/genericity.html" class="sidebar-link">泛型</a></li><li><a href="/typescript/enum/enum.html" class="sidebar-link">枚举</a></li><li><a href="/typescript/advanced-type/advanced-type.html" class="sidebar-link">高级类型</a></li><li><a href="/typescript/module/module.html" class="sidebar-link">模块</a></li><li><a href="/typescript/decorator/decorator.html" class="sidebar-link">装饰器</a></li><li><a href="/typescript/tsconfig/tsconfig.html" class="sidebar-link">tsconfig</a></li><li><a href="/typescript/example/example.html" class="sidebar-link">例子</a></li><li><a href="/typescript/tool/tool.html" class="sidebar-link">用法</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NodeJs</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>动画</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>脚手架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>微前端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>同构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>serverless</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>跨端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>移动端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>桌面端</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>浏览器</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Monorepo</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Chrome</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>引擎</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>DevOps</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>流程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>灰度</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>监控</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>部署</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>发布</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>调试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>测试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程范式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/design-patterns/origin" class="sidebar-heading clickable"><span>设计模式</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机网络</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>操作系统</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>文档管理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>C++</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Linux</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>中国近代史纲要</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>马克思主义基本原理概述</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="类型兼容"><a href="#类型兼容" class="header-anchor">#</a> 类型兼容</h1> <h2 id="结构化类型"><a href="#结构化类型" class="header-anchor">#</a> 结构化类型</h2> <p>鸭子类型的概念来自一个古老的英语成语：“如果它走起路来像一只鸭子，叫起来也像一只鸭子，那么它就是一只鸭子。”在 TypeScript（或更一般地说，静态类型语言）的上下文中，鸭子类型意味着一个对象的类型不是由它继承或实现的具体类别决定的，而是由它具有的结构决定的。</p> <p>本文将全面深入地探讨 TypeScript 中的鸭子类型，以及如何在实际的开发中应用和利用鸭子类型。</p> <h3 id="定义和示例"><a href="#定义和示例" class="header-anchor">#</a> 定义和示例</h3> <p>鸭子类型的概念来自一个古老的英语成语：“如果它走起路来像一只鸭子，叫起来也像一只鸭子，那么它就是一只鸭子。”在 TypeScript（或更一般地说，静态类型语言）的上下文中，鸭子类型意味着一个对象的类型不是由它继承或实现的具体类别决定的，而是由它具有的结构决定的。</p> <p>这是一个简单的鸭子类型示例：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Duck</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">walk</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
    <span class="token function-variable function">quack</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">doDuckThings</span><span class="token punctuation">(</span>duck<span class="token operator">:</span> Duck<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    duck<span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    duck<span class="token punctuation">.</span><span class="token function">quack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> myDuck <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">walk</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Walking like a duck'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">quack</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Quacking like a duck'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function-variable function">swim</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Swimming like a duck'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">doDuckThings</span><span class="token punctuation">(</span>myDuck<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>在这个例子中，我们定义了一个 Duck 接口和一个 doDuckThings 函数，这个函数需要一个 Duck 类型的参数。然后我们创建了一个 myDuck 对象，它有 walk、quack 和 swim 这三个方法。尽管 myDuck 并没有显式地声明它实现了 Duck 接口，但是由于 myDuck 的结构满足了 Duck 接口的要求（即 myDuck 有 walk 和 quack 这两个方法），我们可以将 myDuck 作为参数传递给 doDuckThings 函数。</p> <p>这就是鸭子类型的基本概念：只要一个对象的结构满足了接口的要求，我们就可以把这个对象看作是这个接口的实例，而不管这个对象的实际类型是什么。</p> <h3 id="优点"><a href="#优点" class="header-anchor">#</a> 优点</h3> <ul><li><p>代码的灵活性</p> <p>鸭子类型增加了代码的灵活性。我们可以创建和使用满足特定接口的任何对象，而不必担心它们的具体类型。这使得我们可以更容易地编写通用的代码，因为我们的代码只依赖于对象的结构，而不是对象的具体类型。</p></li> <li><p>代码的复用</p> <p>鸭子类型有助于代码的复用。由于我们的函数和方法只依赖于对象的结构，我们可以在不同的上下文中重用这些函数和方法，只要传入的对象满足所需的结构。</p> <p>例如，我们可以写一个函数，它接受一个具有 toString 方法的任何对象，然后返回这个对象的字符串表示。由于几乎所有的 JavaScript 对象都有 toString 方法，我们可以在许多不同的上下文中重用这个函数。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">function</span> <span class="token function">toString</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token function-variable function">toString</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;123&quot;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;1,2,3&quot;</span>
<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;[object Object]&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li><p>与 JavaScript 的互操作性</p> <p>鸭子类型提高了 TypeScript 与 JavaScript 的互操作性。由于 JavaScript 是一种动态类型语言，我们经常需要处理的对象可能没有明确的类型。鸭子类型使我们能够在 TypeScript 中安全地处理这些对象，只要它们的结构满足我们的需求。</p> <p>例如，我们可能从一个 JavaScript 库获取一个对象，这个对象有一个 forEach 方法。我们不关心这个对象的具体类型，我们只关心它是否有 forEach 方法。使用鸭子类型，我们可以定义一个接口来描述这个对象的结构，然后在 TypeScript 中安全地使用这个对象。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Iterable</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">forEach</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>item<span class="token operator">:</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">processItems</span><span class="token punctuation">(</span>iterable<span class="token operator">:</span> Iterable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    iterable<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> jsArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// From a JavaScript library</span>
<span class="token function">processItems</span><span class="token punctuation">(</span>jsArray<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li></ul> <h3 id="鸭子类型的局限性"><a href="#鸭子类型的局限性" class="header-anchor">#</a> 鸭子类型的局限性</h3> <ul><li><p>类型安全</p> <p>鸭子类型可能会降低代码的类型安全性。因为 TypeScript 的类型检查器只检查对象是否满足接口的结构，而不检查对象是否真的是接口所期望的类型。如果一个对象恰好有与接口相同的属性和方法，但实际上它并不是接口所期望的类型，TypeScript 的类型检查器可能无法发现这个错误。</p> <p>例如，我们可能有一个 Dog 类型和一个 Cat 类型，它们都有一个 bark 方法。我们可能会错误地将一个 `Cat</p> <p>对象传递给一个期望Dog` 对象的函数，而 TypeScript 的类型检查器无法发现这个错误。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Dog</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">bark</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">letDogBark</span><span class="token punctuation">(</span>dog<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dog<span class="token punctuation">.</span><span class="token function">bark</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">bark</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Meow...'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// Cats don't bark!</span>
    <span class="token function-variable function">purr</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Purr...'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">letDogBark</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No error, but it's wrong!</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>在这种情况下，我们需要更仔细地设计我们的类型和接口，以避免混淆。</p></li> <li><p>易读性和可维护性</p> <p>鸭子类型可能会降低代码的易读性和可维护性。因为我们的代码只依赖于对象的结构，而不是对象的具体类型，这可能会使代码更难理解和维护。</p> <p>为了提高易读性和可维护性，我们需要清晰地记录我们的接口和函数期望的对象结构。TypeScript 的类型注解和接口提供了一种强大的工具来实现这一点。</p></li></ul> <h3 id="最佳实践"><a href="#最佳实践" class="header-anchor">#</a> 最佳实践</h3> <ul><li><p>清晰地定义接口</p> <p>我们应该清晰地定义我们的接口，以描述我们的函数和方法期望的对象结构。这有助于提高代码的易读性和可维护性。</p> <p>例如，如果我们有一个函数，它期望一个具有 name 和 age 属性的对象，我们应该定义一个接口来描述这个结构。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
    age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span>person<span class="token operator">:</span> Person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello, my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>person<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> and I'm </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>person<span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> years old.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>适度使用鸭子类型</p></li></ul> <p>我们应该适度地使用鸭子类型。虽然鸭子类型有许多优点，但如果过度使用，可能会导致类型安全性的问题，以及易读性和可维护性的降低。我们应该在类型安全性、易读性、可维护性和灵活性之间找到一个平衡。</p> <p>在某些情况下，我们可能更希望使用类和继承，而不是鸭子类型。例如，如果我们有一组紧密相关的类型，它们有共享的行为和状态，使用类和继承可能更合适。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>

    <span class="token keyword">constructor</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p<span class="token operator">:</span> Named<span class="token punctuation">;</span>
<span class="token comment">// OK, because of structural typing</span>
p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">'mike'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>在这个例子中，尽管 Person 类并没有显式地实现 Named 接口，但是因为 Person 类有一个 name 属性，所以我们可以把 Person 的实例赋值给 Named 类型的变量。这是由于 TypeScript 的 &quot;鸭子类型&quot; 或 &quot;结构化类型&quot; 系统导致的。</p> <h2 id="协变和逆变"><a href="#协变和逆变" class="header-anchor">#</a> 协变和逆变</h2> <p>在类型系统中，协变和逆变是对类型比较(类型兼容)一种形式化描述。在一些类型系统中，例如 Java，这些概念是显式嵌入到语言中的，例如使用extends关键字表示协变，使用super关键字表示逆变。在其他一些类型系统中，例如 TypeScript，协变和逆变的规则是隐式嵌入的，通过类型兼容性检查来实现。</p> <p>协变和逆变的存在使得类型系统具有更大的灵活性。例如，如果你有一个Animal类型的数组，并且你有一个Dog类型的对象（假设Dog是Animal的子类型），那么你应该能够将Dog对象添加到Animal数组中。这就是协变。反过来，如果你有一个处理Animal类型对象的函数，并且你有一个Dog类型的对象，你应该可以使用这个函数来处理Dog对象。这就是逆变。</p> <p>协变和逆变还可以帮助我们创建更通用的代码。例如，如果你有一个可以处理任何Animal的函数，那么这个函数应该能够处理任何Animal的子类型。这意味着，你可以编写一段只依赖于Animal类型的代码，然后使用这段代码处理任何Animal的子类型。</p> <h3 id="协变-covariance"><a href="#协变-covariance" class="header-anchor">#</a> 协变（Covariance）</h3> <p>协变描述的是如果存在类型A和B，并且A是B的子类型，那么我们就可以说由A组成的复合类型（例如<code>Array&lt;A&gt;</code>或者(a: A) =&gt; void）也是由B组成的相应复合类型（例如<code>Array&lt;B&gt;</code>或者(b: B) =&gt; void）的子类型。</p> <p>让我们通过一个例子来理解协变。假设我们有两个类型Animal和Dog，其中Dog是Animal的子类型。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Animal</span> <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Dog</span> <span class="token operator">=</span> Animal <span class="token operator">&amp;</span> <span class="token punctuation">{</span> breed<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> dogs<span class="token operator">:</span> Dog<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&quot;Fido&quot;</span><span class="token punctuation">,</span> breed<span class="token operator">:</span> <span class="token string">&quot;Poodle&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> animals<span class="token operator">:</span> Animal<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> dogs<span class="token punctuation">;</span>  <span class="token comment">// OK because Dog extends Animal, Dog[] is a subtype of Animal[]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这里我们可以将类型为Dog[]的dogs赋值给类型为Animal[]的animals，因为Dog[]是Animal[]的子类型，所以数组是协变的。</p> <h4 id="类型的向下兼容性"><a href="#类型的向下兼容性" class="header-anchor">#</a> 类型的向下兼容性</h4> <p>协变是类型系统中的一个基本概念，它描述的是类型的“向下兼容性”。如果一个类型A可以被看作是另一个类型B的子类型（即A可以被安全地用在期望B的任何地方），那么我们就说A到B是协变的。这是类型系统中最常见和直观的一种关系，例如在面向对象编程中的继承就是协变的一种表现。</p> <p>在TypeScript中，所有的类型都是自身的子类型（即每个类型到自身是协变的），并且null和undefined类型是所有类型的子类型。除此之外，接口和类也可以通过继承来形成协变关系。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Dog</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  breed<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> myDog<span class="token operator">:</span> Dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> myAnimal<span class="token operator">:</span> Animal <span class="token operator">=</span> myDog<span class="token punctuation">;</span>  <span class="token comment">// OK，因为Dog是Animal的子类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>这个例子中，我们可以将一个Dog对象赋值给一个Animal类型的变量，因为Dog到Animal是协变的。</p> <p>在TypeScript中，泛型类型也是协变的。例如，如果类型A是类型B的子类型，那么<code>Array&lt;A&gt;</code>就是<code>Array&lt;B&gt;</code>的子类型。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">let</span> dogs<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Dog<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> animals<span class="token operator">:</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span>Animal<span class="token operator">&gt;</span> <span class="token operator">=</span> dogs<span class="token punctuation">;</span>  <span class="token comment">// OK，因为Array&lt;Dog&gt;是Array&lt;Animal&gt;的子类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="逆变-contravariance"><a href="#逆变-contravariance" class="header-anchor">#</a> 逆变（Contravariance）</h3> <p>逆变是协变的反面。如果存在类型A和B，并且A是B的子类型，那么我们就可以说由B组成的某些复合类型是由A组成的相应复合类型的子类型。</p> <p>这在函数参数中最常见。让我们来看一个例子：</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Animal</span> <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">type</span> <span class="token class-name">Dog</span> <span class="token operator">=</span> Animal <span class="token operator">&amp;</span> <span class="token punctuation">{</span> breed<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> <span class="token function-variable function">dogHandler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dog<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>breed<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">animalHandler</span><span class="token operator">:</span> <span class="token punctuation">(</span>animal<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token operator">=</span> dogHandler<span class="token punctuation">;</span>  <span class="token comment">// Error! </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>在这个例子中，我们不能将类型为(dog: Dog) =&gt; void的dogHandler赋值给类型为(animal: Animal) =&gt; void的animalHandler。因为如果我们传递一个Animal（并非所有的Animal都是Dog）给animalHandler，那么在执行dogHandler函数的时候，就可能会引用不存在的breed属性。因此，函数的参数类型是逆变的。</p> <h4 id="类型的向上兼容性"><a href="#类型的向上兼容性" class="header-anchor">#</a> 类型的向上兼容性</h4> <p>逆变描述的是类型的“向上兼容性”。如果一个类型A可以被看作是另一个类型B的超类型（即B可以被安全地用在期望A的任何地方），那么我们就说A到B是逆变的。在函数参数类型的兼容性检查中，TypeScript使用了逆变。</p> <div class="language-ts line-numbers-mode"><pre class="language-ts"><code><span class="token keyword">type</span> <span class="token class-name">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arg<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> animalHandler<span class="token operator">:</span> <span class="token function-variable function">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>animal<span class="token operator">:</span> Animal<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> dogHandler<span class="token operator">:</span> <span class="token function-variable function">Handler</span> <span class="token operator">=</span> <span class="token punctuation">(</span>dog<span class="token operator">:</span> Dog<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// OK，因为Animal是Dog的超类型</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这个例子中，我们可以将一个处理Dog的函数赋值给一个处理Animal的函数类型的变量，因为Animal是Dog的超类型，所以(dog: Dog) =&gt; void类型是(animal: Animal) =&gt; void`类型的子类型。</p> <p>这看起来可能有些反直觉，但实际上是为了保证类型安全。因为在执行dogHandler函数时，我们可以安全地传入一个Animal对象，而不需要担心它可能不是Dog类型。</p> <h3 id="协变与逆变的平衡"><a href="#协变与逆变的平衡" class="header-anchor">#</a> 协变与逆变的平衡</h3> <p>协变和逆变在大多数情况下都可以提供合适的类型检查，但是它们并非完美无缺。在实际应用中，我们必须关注可能的边界情况，以避免运行时错误。在某些情况下，我们甚至需要主动破坏类型的协变或逆变，以获得更强的类型安全。例如，如果我们需要向一个Dog[]数组中添加Animal对象，我们可能需要将这个数组的类型声明为Animal[]，以防止添加不兼容的类型。</p> <p>总的来说，协变和逆变是理解和应用TypeScript类型系统的重要工具，但我们必须在灵活性和类型安全之间找到合适的平衡。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/26/2023, 11:24:03 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/typescript/type-declaration-extension/type-declaration-extension.html" class="prev">
        类型声明扩展
      </a></span> <span class="next"><a href="/typescript/statement/statement.html">
        声明
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.5dd33da1.js" defer></script><script src="/assets/js/2.bffc4eaa.js" defer></script><script src="/assets/js/142.bfb1dbf7.js" defer></script>
  </body>
</html>
